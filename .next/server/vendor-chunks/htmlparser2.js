"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/htmlparser2";
exports.ids = ["vendor-chunks/htmlparser2"];
exports.modules = {

/***/ "(rsc)/./node_modules/htmlparser2/dist/esm/Parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/htmlparser2/dist/esm/Parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer.js */ \"(rsc)/./node_modules/htmlparser2/dist/esm/Tokenizer.js\");\n/* harmony import */ var entities_decode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! entities/decode */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode.js\");\n\n\nconst formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nconst pTag = new Set([\"p\"]);\nconst tableSectionTags = new Set([\"thead\", \"tbody\"]);\nconst ddtTags = new Set([\"dd\", \"dt\"]);\nconst rtpTags = new Set([\"rt\", \"rp\"]);\nconst openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nconst voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nconst foreignContextElements = new Set([\"math\", \"svg\"]);\nconst htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nconst reNameEnd = /\\s|\\//;\nclass Parser {\n    constructor(cbs, options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.buffers = [];\n        this.bufferOffset = 0;\n        /** The index of the last written buffer. Used when resuming after a `pause()`. */\n        this.writeIndex = 0;\n        /** Indicates whether the parser has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.htmlMode = !this.options.xmlMode;\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;\n        this.recognizeSelfClosing =\n            (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;\n        this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.options, this);\n        this.foreignContext = [!this.htmlMode];\n        (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    ontext(start, endIndex) {\n        var _a, _b;\n        const data = this.getSlice(start, endIndex);\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = endIndex;\n    }\n    /** @internal */\n    ontextentity(cp, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0,entities_decode__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(cp));\n        this.startIndex = endIndex;\n    }\n    /**\n     * Checks if the current tag is a void element. Override this if you want\n     * to specify your own additional void elements.\n     */\n    isVoidElement(name) {\n        return this.htmlMode && voidElements.has(name);\n    }\n    /** @internal */\n    onopentagname(start, endIndex) {\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    }\n    emitOpenTag(name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        const impliesClose = this.htmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {\n                const element = this.stack.shift();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.unshift(name);\n            if (this.htmlMode) {\n                if (foreignContextElements.has(name)) {\n                    this.foreignContext.unshift(true);\n                }\n                else if (htmlIntegrationElements.has(name)) {\n                    this.foreignContext.unshift(false);\n                }\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    }\n    endOpenTag(isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    }\n    /** @internal */\n    onopentagend(endIndex) {\n        this.endIndex = endIndex;\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onclosetag(start, endIndex) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (this.htmlMode &&\n            (foreignContextElements.has(name) ||\n                htmlIntegrationElements.has(name))) {\n            this.foreignContext.shift();\n        }\n        if (!this.isVoidElement(name)) {\n            const pos = this.stack.indexOf(name);\n            if (pos !== -1) {\n                for (let index = 0; index <= pos; index++) {\n                    const element = this.stack.shift();\n                    // We know the stack has sufficient elements.\n                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);\n                }\n            }\n            else if (this.htmlMode && name === \"p\") {\n                // Implicit open before close\n                this.emitOpenTag(\"p\");\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (this.htmlMode && name === \"br\") {\n            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\");\n            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", {}, true);\n            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, \"br\", false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onselfclosingtag(endIndex) {\n        this.endIndex = endIndex;\n        if (this.recognizeSelfClosing || this.foreignContext[0]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend(endIndex);\n        }\n    }\n    closeCurrentTag(isOpenImplied) {\n        var _a, _b;\n        const name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[0] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.shift();\n        }\n    }\n    /** @internal */\n    onattribname(start, endIndex) {\n        this.startIndex = start;\n        const name = this.getSlice(start, endIndex);\n        this.attribname = this.lowerCaseAttributeNames\n            ? name.toLowerCase()\n            : name;\n    }\n    /** @internal */\n    onattribdata(start, endIndex) {\n        this.attribvalue += this.getSlice(start, endIndex);\n    }\n    /** @internal */\n    onattribentity(cp) {\n        this.attribvalue += (0,entities_decode__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(cp);\n    }\n    /** @internal */\n    onattribend(quote, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.Double\n            ? '\"'\n            : quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.Single\n                ? \"'\"\n                : quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.NoValue\n                    ? undefined\n                    : null);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribvalue = \"\";\n    }\n    getInstructionName(value) {\n        const index = value.search(reNameEnd);\n        let name = index < 0 ? value : value.substr(0, index);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    }\n    /** @internal */\n    ondeclaration(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onprocessinginstruction(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncomment(start, endIndex, offset) {\n        var _a, _b, _c, _d;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncdata(start, endIndex, offset) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex - offset);\n        if (!this.htmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onend() {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (let index = 0; index < this.stack.length; index++) {\n                this.cbs.onclosetag(this.stack[index], true);\n            }\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    reset() {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack.length = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this.buffers.length = 0;\n        this.foreignContext.length = 0;\n        this.foreignContext.unshift(!this.htmlMode);\n        this.bufferOffset = 0;\n        this.writeIndex = 0;\n        this.ended = false;\n    }\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    parseComplete(data) {\n        this.reset();\n        this.end(data);\n    }\n    getSlice(start, end) {\n        while (start - this.bufferOffset >= this.buffers[0].length) {\n            this.shiftBuffer();\n        }\n        let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n        while (end - this.bufferOffset > this.buffers[0].length) {\n            this.shiftBuffer();\n            slice += this.buffers[0].slice(0, end - this.bufferOffset);\n        }\n        return slice;\n    }\n    shiftBuffer() {\n        this.bufferOffset += this.buffers[0].length;\n        this.writeIndex--;\n        this.buffers.shift();\n    }\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    write(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n            return;\n        }\n        this.buffers.push(chunk);\n        if (this.tokenizer.running) {\n            this.tokenizer.write(chunk);\n            this.writeIndex++;\n        }\n    }\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    end(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".end() after done!\"));\n            return;\n        }\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        this.tokenizer.end();\n    }\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    pause() {\n        this.tokenizer.pause();\n    }\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    resume() {\n        this.tokenizer.resume();\n        while (this.tokenizer.running &&\n            this.writeIndex < this.buffers.length) {\n            this.tokenizer.write(this.buffers[this.writeIndex++]);\n        }\n        if (this.ended)\n            this.tokenizer.end();\n    }\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    parseChunk(chunk) {\n        this.write(chunk);\n    }\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    done(chunk) {\n        this.end(chunk);\n    }\n}\n//# sourceMappingURL=Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRDtBQUNOO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YscURBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsOERBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUksb0RBQVM7QUFDbEo7QUFDQSx3QkFBd0Isb0RBQVM7QUFDakM7QUFDQSw0QkFBNEIsb0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSyxPQUFPLE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSyxPQUFPLE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLE1BQU07QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJjYWRlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vUGFyc2VyLmpzPzI3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRva2VuaXplciwgeyBRdW90ZVR5cGUgfSBmcm9tIFwiLi9Ub2tlbml6ZXIuanNcIjtcbmltcG9ydCB7IGZyb21Db2RlUG9pbnQgfSBmcm9tIFwiZW50aXRpZXMvZGVjb2RlXCI7XG5jb25zdCBmb3JtVGFncyA9IG5ldyBTZXQoW1xuICAgIFwiaW5wdXRcIixcbiAgICBcIm9wdGlvblwiLFxuICAgIFwib3B0Z3JvdXBcIixcbiAgICBcInNlbGVjdFwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJkYXRhbGlzdFwiLFxuICAgIFwidGV4dGFyZWFcIixcbl0pO1xuY29uc3QgcFRhZyA9IG5ldyBTZXQoW1wicFwiXSk7XG5jb25zdCB0YWJsZVNlY3Rpb25UYWdzID0gbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKTtcbmNvbnN0IGRkdFRhZ3MgPSBuZXcgU2V0KFtcImRkXCIsIFwiZHRcIl0pO1xuY29uc3QgcnRwVGFncyA9IG5ldyBTZXQoW1wicnRcIiwgXCJycFwiXSk7XG5jb25zdCBvcGVuSW1wbGllc0Nsb3NlID0gbmV3IE1hcChbXG4gICAgW1widHJcIiwgbmV3IFNldChbXCJ0clwiLCBcInRoXCIsIFwidGRcIl0pXSxcbiAgICBbXCJ0aFwiLCBuZXcgU2V0KFtcInRoXCJdKV0sXG4gICAgW1widGRcIiwgbmV3IFNldChbXCJ0aGVhZFwiLCBcInRoXCIsIFwidGRcIl0pXSxcbiAgICBbXCJib2R5XCIsIG5ldyBTZXQoW1wiaGVhZFwiLCBcImxpbmtcIiwgXCJzY3JpcHRcIl0pXSxcbiAgICBbXCJsaVwiLCBuZXcgU2V0KFtcImxpXCJdKV0sXG4gICAgW1wicFwiLCBwVGFnXSxcbiAgICBbXCJoMVwiLCBwVGFnXSxcbiAgICBbXCJoMlwiLCBwVGFnXSxcbiAgICBbXCJoM1wiLCBwVGFnXSxcbiAgICBbXCJoNFwiLCBwVGFnXSxcbiAgICBbXCJoNVwiLCBwVGFnXSxcbiAgICBbXCJoNlwiLCBwVGFnXSxcbiAgICBbXCJzZWxlY3RcIiwgZm9ybVRhZ3NdLFxuICAgIFtcImlucHV0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJvdXRwdXRcIiwgZm9ybVRhZ3NdLFxuICAgIFtcImJ1dHRvblwiLCBmb3JtVGFnc10sXG4gICAgW1wiZGF0YWxpc3RcIiwgZm9ybVRhZ3NdLFxuICAgIFtcInRleHRhcmVhXCIsIGZvcm1UYWdzXSxcbiAgICBbXCJvcHRpb25cIiwgbmV3IFNldChbXCJvcHRpb25cIl0pXSxcbiAgICBbXCJvcHRncm91cFwiLCBuZXcgU2V0KFtcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCJdKV0sXG4gICAgW1wiZGRcIiwgZGR0VGFnc10sXG4gICAgW1wiZHRcIiwgZGR0VGFnc10sXG4gICAgW1wiYWRkcmVzc1wiLCBwVGFnXSxcbiAgICBbXCJhcnRpY2xlXCIsIHBUYWddLFxuICAgIFtcImFzaWRlXCIsIHBUYWddLFxuICAgIFtcImJsb2NrcXVvdGVcIiwgcFRhZ10sXG4gICAgW1wiZGV0YWlsc1wiLCBwVGFnXSxcbiAgICBbXCJkaXZcIiwgcFRhZ10sXG4gICAgW1wiZGxcIiwgcFRhZ10sXG4gICAgW1wiZmllbGRzZXRcIiwgcFRhZ10sXG4gICAgW1wiZmlnY2FwdGlvblwiLCBwVGFnXSxcbiAgICBbXCJmaWd1cmVcIiwgcFRhZ10sXG4gICAgW1wiZm9vdGVyXCIsIHBUYWddLFxuICAgIFtcImZvcm1cIiwgcFRhZ10sXG4gICAgW1wiaGVhZGVyXCIsIHBUYWddLFxuICAgIFtcImhyXCIsIHBUYWddLFxuICAgIFtcIm1haW5cIiwgcFRhZ10sXG4gICAgW1wibmF2XCIsIHBUYWddLFxuICAgIFtcIm9sXCIsIHBUYWddLFxuICAgIFtcInByZVwiLCBwVGFnXSxcbiAgICBbXCJzZWN0aW9uXCIsIHBUYWddLFxuICAgIFtcInRhYmxlXCIsIHBUYWddLFxuICAgIFtcInVsXCIsIHBUYWddLFxuICAgIFtcInJ0XCIsIHJ0cFRhZ3NdLFxuICAgIFtcInJwXCIsIHJ0cFRhZ3NdLFxuICAgIFtcInRib2R5XCIsIHRhYmxlU2VjdGlvblRhZ3NdLFxuICAgIFtcInRmb290XCIsIHRhYmxlU2VjdGlvblRhZ3NdLFxuXSk7XG5jb25zdCB2b2lkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcImFyZWFcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2Vmb250XCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29sXCIsXG4gICAgXCJjb21tYW5kXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImhyXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpc2luZGV4XCIsXG4gICAgXCJrZXlnZW5cIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInBhcmFtXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ3YnJcIixcbl0pO1xuY29uc3QgZm9yZWlnbkNvbnRleHRFbGVtZW50cyA9IG5ldyBTZXQoW1wibWF0aFwiLCBcInN2Z1wiXSk7XG5jb25zdCBodG1sSW50ZWdyYXRpb25FbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwibWlcIixcbiAgICBcIm1vXCIsXG4gICAgXCJtblwiLFxuICAgIFwibXNcIixcbiAgICBcIm10ZXh0XCIsXG4gICAgXCJhbm5vdGF0aW9uLXhtbFwiLFxuICAgIFwiZm9yZWlnbm9iamVjdFwiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwidGl0bGVcIixcbl0pO1xuY29uc3QgcmVOYW1lRW5kID0gL1xcc3xcXC8vO1xuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoY2JzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGxhc3QgZXZlbnQuICovXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIHRoZSBzdGFydCBpbmRleCBvZiB0aGUgY3VycmVudCBvcGVuIHRhZyxcbiAgICAgICAgICogc28gd2UgY2FuIHVwZGF0ZSB0aGUgc3RhcnQgaW5kZXggZm9yIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5UYWdTdGFydCA9IDA7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3Qgd3JpdHRlbiBidWZmZXIuIFVzZWQgd2hlbiByZXN1bWluZyBhZnRlciBhIGBwYXVzZSgpYC4gKi9cbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXJzZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzICE9PSBudWxsICYmIGNicyAhPT0gdm9pZCAwID8gY2JzIDoge307XG4gICAgICAgIHRoaXMuaHRtbE1vZGUgPSAhdGhpcy5vcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlVGFnTmFtZXMgPSAoX2EgPSBvcHRpb25zLmxvd2VyQ2FzZVRhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuaHRtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgPVxuICAgICAgICAgICAgKF9iID0gb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy5yZWNvZ25pemVTZWxmQ2xvc2luZyA9XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAhdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgKChfZCA9IG9wdGlvbnMuVG9rZW5pemVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBUb2tlbml6ZXIpKHRoaXMub3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQgPSBbIXRoaXMuaHRtbE1vZGVdO1xuICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgdGhpcyk7XG4gICAgfVxuICAgIC8vIFRva2VuaXplciBldmVudCBoYW5kbGVyc1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbnRleHQoc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleCAtIDE7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBkYXRhKTtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbnRleHRlbnRpdHkoY3AsIGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleCAtIDE7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBmcm9tQ29kZVBvaW50KGNwKSk7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdGFnIGlzIGEgdm9pZCBlbGVtZW50LiBPdmVycmlkZSB0aGlzIGlmIHlvdSB3YW50XG4gICAgICogdG8gc3BlY2lmeSB5b3VyIG93biBhZGRpdGlvbmFsIHZvaWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgaXNWb2lkRWxlbWVudChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0bWxNb2RlICYmIHZvaWRFbGVtZW50cy5oYXMobmFtZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbm9wZW50YWduYW1lKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKG5hbWUpO1xuICAgIH1cbiAgICBlbWl0T3BlblRhZyhuYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5vcGVuVGFnU3RhcnQgPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IGltcGxpZXNDbG9zZSA9IHRoaXMuaHRtbE1vZGUgJiYgb3BlbkltcGxpZXNDbG9zZS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbXBsaWVzQ2xvc2UpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDAgJiYgaW1wbGllc0Nsb3NlLmhhcyh0aGlzLnN0YWNrWzBdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWb2lkRWxlbWVudChuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaHRtbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC51bnNoaWZ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC51bnNoaWZ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9ub3BlbnRhZ25hbWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ub3BlbnRhZylcbiAgICAgICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgIH1cbiAgICBlbmRPcGVuVGFnKGlzSW1wbGllZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLm9wZW5UYWdTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicykge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9ub3BlbnRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMudGFnbmFtZSwgdGhpcy5hdHRyaWJzLCBpc0ltcGxpZWQpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYnMub25jbG9zZXRhZyAmJiB0aGlzLmlzVm9pZEVsZW1lbnQodGhpcy50YWduYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnRhZ25hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbm9wZW50YWdlbmQoZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB0aGlzLmVuZE9wZW5UYWcoZmFsc2UpO1xuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25jbG9zZXRhZyhzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHRtbE1vZGUgJiZcbiAgICAgICAgICAgIChmb3JlaWduQ29udGV4dEVsZW1lbnRzLmhhcyhuYW1lKSB8fFxuICAgICAgICAgICAgICAgIGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWb2lkRWxlbWVudChuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zdGFjay5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDw9IHBvczsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5zdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBzdGFjayBoYXMgc3VmZmljaWVudCBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlbGVtZW50LCBpbmRleCAhPT0gcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmh0bWxNb2RlICYmIG5hbWUgPT09IFwicFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgb3BlbiBiZWZvcmUgY2xvc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKFwicFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ3VycmVudFRhZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmh0bWxNb2RlICYmIG5hbWUgPT09IFwiYnJcIikge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBlbWl0T3BlblRhZ2AgZm9yIGltcGxpY2l0IG9wZW4sIGFzIGBicmAgd291bGQgYmUgaW1wbGljaXRseSBjbG9zZWQuXG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25vcGVudGFnbmFtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIFwiYnJcIik7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgXCJiclwiLCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICAoX2ggPSAoX2cgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoX2csIFwiYnJcIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbnNlbGZjbG9zaW5ndGFnKGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMucmVjb2duaXplU2VsZkNsb3NpbmcgfHwgdGhpcy5mb3JlaWduQ29udGV4dFswXSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZy5cbiAgICAgICAgICAgIHRoaXMub25vcGVudGFnZW5kKGVuZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZUN1cnJlbnRUYWcoaXNPcGVuSW1wbGllZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50YWduYW1lO1xuICAgICAgICB0aGlzLmVuZE9wZW5UYWcoaXNPcGVuSW1wbGllZCk7XG4gICAgICAgIC8vIFNlbGYtY2xvc2luZyB0YWdzIHdpbGwgYmUgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgaWYgKHRoaXMuc3RhY2tbMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcGVuaW5nIHRhZyBpc24ndCBpbXBsaWVkLCB0aGUgY2xvc2luZyB0YWcgaGFzIHRvIGJlIGltcGxpZWQuXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5hbWUsICFpc09wZW5JbXBsaWVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25hdHRyaWJuYW1lKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gdGhpcy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1xuICAgICAgICAgICAgPyBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogbmFtZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uYXR0cmliZGF0YShzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSArPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbmF0dHJpYmVudGl0eShjcCkge1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlICs9IGZyb21Db2RlUG9pbnQoY3ApO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25hdHRyaWJlbmQocXVvdGUsIGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uYXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy5hdHRyaWJuYW1lLCB0aGlzLmF0dHJpYnZhbHVlLCBxdW90ZSA9PT0gUXVvdGVUeXBlLkRvdWJsZVxuICAgICAgICAgICAgPyAnXCInXG4gICAgICAgICAgICA6IHF1b3RlID09PSBRdW90ZVR5cGUuU2luZ2xlXG4gICAgICAgICAgICAgICAgPyBcIidcIlxuICAgICAgICAgICAgICAgIDogcXVvdGUgPT09IFF1b3RlVHlwZS5Ob1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnMgJiZcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJzLCB0aGlzLmF0dHJpYm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnNbdGhpcy5hdHRyaWJuYW1lXSA9IHRoaXMuYXR0cmlidmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGdldEluc3RydWN0aW9uTmFtZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlLnNlYXJjaChyZU5hbWVFbmQpO1xuICAgICAgICBsZXQgbmFtZSA9IGluZGV4IDwgMCA/IHZhbHVlIDogdmFsdWUuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbmRlY2xhcmF0aW9uKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldEluc3RydWN0aW9uTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihgISR7bmFtZX1gLCBgISR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldEluc3RydWN0aW9uTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihgPyR7bmFtZX1gLCBgPyR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uY29tbWVudChzdGFydCwgZW5kSW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY29tbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4IC0gb2Zmc2V0KSk7XG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbmNvbW1lbnRlbmQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uY2RhdGEoc3RhcnQsIGVuZEluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXggLSBvZmZzZXQpO1xuICAgICAgICBpZiAoIXRoaXMuaHRtbE1vZGUgfHwgdGhpcy5vcHRpb25zLnJlY29nbml6ZUNEQVRBKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jZGF0YXN0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdmFsdWUpO1xuICAgICAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9uY2RhdGFlbmQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfaCA9IChfZyA9IHRoaXMuY2JzKS5vbmNvbW1lbnQpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nLCBgW0NEQVRBWyR7dmFsdWV9XV1gKTtcbiAgICAgICAgICAgIChfayA9IChfaiA9IHRoaXMuY2JzKS5vbmNvbW1lbnRlbmQpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYWxsKF9qKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25lbmQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbmNsb3NldGFnKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGVuZCBpbmRleCBmb3IgYWxsIHJlbWFpbmluZyB0YWdzXG4gICAgICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5zdGFydEluZGV4O1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3RhY2subGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnN0YWNrW2luZGV4XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcGFyc2VyIHRvIGEgYmxhbmsgc3RhdGUsIHJlYWR5IHRvIHBhcnNlIGEgbmV3IEhUTUwgZG9jdW1lbnRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25yZXNldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLnRva2VuaXplci5yZXNldCgpO1xuICAgICAgICB0aGlzLnRhZ25hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSAwO1xuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQudW5zaGlmdCghdGhpcy5odG1sTW9kZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHBhcnNlciwgdGhlbiBwYXJzZXMgYSBjb21wbGV0ZSBkb2N1bWVudCBhbmRcbiAgICAgKiBwdXNoZXMgaXQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBEb2N1bWVudCB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBwYXJzZUNvbXBsZXRlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmVuZChkYXRhKTtcbiAgICB9XG4gICAgZ2V0U2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICB3aGlsZSAoc3RhcnQgLSB0aGlzLmJ1ZmZlck9mZnNldCA+PSB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5idWZmZXJzWzBdLnNsaWNlKHN0YXJ0IC0gdGhpcy5idWZmZXJPZmZzZXQsIGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0ID4gdGhpcy5idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdEJ1ZmZlcigpO1xuICAgICAgICAgICAgc2xpY2UgKz0gdGhpcy5idWZmZXJzWzBdLnNsaWNlKDAsIGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIHNoaWZ0QnVmZmVyKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXgtLTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnNoaWZ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNodW5rIG9mIGRhdGEgYW5kIGNhbGxzIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBDaHVuayB0byBwYXJzZS5cbiAgICAgKi9cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXcgRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIucnVubmluZykge1xuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBhbmQgY2xlYXJzIHRoZSBzdGFjaywgY2FsbHMgb25lbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgT3B0aW9uYWwgZmluYWwgY2h1bmsgdG8gcGFyc2UuXG4gICAgICovXG4gICAgZW5kKGNodW5rKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25lcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcihcIi5lbmQoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRva2VuaXplci5lbmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBhcnNpbmcuIFRoZSBwYXJzZXIgd29uJ3QgZW1pdCBldmVudHMgdW50aWwgYHJlc3VtZWAgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplci5wYXVzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHBhcnNpbmcgYWZ0ZXIgYHBhdXNlYCB3YXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucmVzdW1lKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnRva2VuaXplci5ydW5uaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXggPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuaXplci53cml0ZSh0aGlzLmJ1ZmZlcnNbdGhpcy53cml0ZUluZGV4KytdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgd3JpdGVgLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgQ2h1bmsgdG8gcGFyc2UuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBwYXJzZUNodW5rKGNodW5rKSB7XG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgZW5kYCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIE9wdGlvbmFsIGZpbmFsIGNodW5rIHRvIHBhcnNlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZG9uZShjaHVuaykge1xuICAgICAgICB0aGlzLmVuZChjaHVuayk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/dist/esm/Parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/dist/esm/Tokenizer.js":
/*!********************************************************!*\
  !*** ./node_modules/htmlparser2/dist/esm/Tokenizer.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuoteType: () => (/* binding */ QuoteType),\n/* harmony export */   \"default\": () => (/* binding */ Tokenizer)\n/* harmony export */ });\n/* harmony import */ var entities_decode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! entities/decode */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode.js\");\n\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n    CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n    CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n    CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n    CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    CharCodes[CharCodes[\"Number\"] = 35] = \"Number\";\n    CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n    CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n    CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n    CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n    CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n    CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n    CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n    CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n    CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n    CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n    CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n    CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n    CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n    CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n    State[State[\"Text\"] = 1] = \"Text\";\n    State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n    State[State[\"InTagName\"] = 3] = \"InTagName\";\n    State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n    State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n    State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n    State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n    // Attributes\n    State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n    State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n    State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n    State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n    State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n    State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n    State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n    // Declarations\n    State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n    State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n    // Processing instructions\n    State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n    // Comments & CDATA\n    State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n    State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n    State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n    State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n    // Special tags\n    State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n    State[State[\"BeforeSpecialT\"] = 23] = \"BeforeSpecialT\";\n    State[State[\"SpecialStartSequence\"] = 24] = \"SpecialStartSequence\";\n    State[State[\"InSpecialTag\"] = 25] = \"InSpecialTag\";\n    State[State[\"InEntity\"] = 26] = \"InEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n    return (c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn);\n}\nfunction isEndOfTagSection(c) {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));\n}\nvar QuoteType;\n(function (QuoteType) {\n    QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n    QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n    QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n    QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nconst Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n    TextareaEnd: new Uint8Array([\n        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,\n    ]), // `</textarea`\n    XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`\n};\nclass Tokenizer {\n    constructor({ xmlMode = false, decodeEntities = true, }, cbs) {\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this.state = State.Text;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this.index = 0;\n        /** The start of the last entity. */\n        this.entityStart = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = State.Text;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** The offset of the current buffer. */\n        this.offset = 0;\n        this.currentSequence = undefined;\n        this.sequenceIndex = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityDecoder = new entities_decode__WEBPACK_IMPORTED_MODULE_0__.EntityDecoder(xmlMode ? entities_decode__WEBPACK_IMPORTED_MODULE_0__.xmlDecodeTree : entities_decode__WEBPACK_IMPORTED_MODULE_0__.htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));\n    }\n    reset() {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.offset = 0;\n    }\n    write(chunk) {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    }\n    end() {\n        if (this.running)\n            this.finish();\n    }\n    pause() {\n        this.running = false;\n    }\n    resume() {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    }\n    stateText(c) {\n        if (c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateSpecialStartSequence(c) {\n        const isEnd = this.sequenceIndex === this.currentSequence.length;\n        const isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    }\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    stateInSpecialTag(c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                const endOfText = this.index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    const actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.startEntity();\n                }\n            }\n            else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    }\n    stateCDATASequence(c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    }\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    fastForwardTo(c) {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n        return false;\n    }\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    stateInCommentLike(c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                }\n                else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    }\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    isTagStartChar(c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    }\n    startSpecial(sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    }\n    stateBeforeTagName(c) {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            const lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (this.xmlMode) {\n                this.state = State.InTagName;\n            }\n            else if (lower === Sequences.ScriptEnd[2]) {\n                this.state = State.BeforeSpecialS;\n            }\n            else if (lower === Sequences.TitleEnd[2] ||\n                lower === Sequences.XmpEnd[2]) {\n                this.state = State.BeforeSpecialT;\n            }\n            else {\n                this.state = State.InTagName;\n            }\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        }\n        else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    }\n    stateInTagName(c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateBeforeClosingTagName(c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        }\n        else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInClosingTagName(c) {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    }\n    stateAfterClosingTagName(c) {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeAttributeName(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            }\n            else {\n                this.state = State.Text;\n            }\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInSelfClosingTag(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateInAttributeName(c) {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = this.index;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    }\n    stateAfterAttributeName(c) {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        }\n        else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateBeforeAttributeValue(c) {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    }\n    handleInAttributeValue(c, quote) {\n        if (c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(quote === CharCodes.DoubleQuote\n                ? QuoteType.Double\n                : QuoteType.Single, this.index + 1);\n            this.state = State.BeforeAttributeName;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateInAttributeValueDoubleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    }\n    stateInAttributeValueSingleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    }\n    stateInAttributeValueNoQuotes(c) {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateBeforeDeclaration(c) {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        }\n        else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    }\n    stateInDeclaration(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateInProcessingInstruction(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeComment(c) {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        }\n        else {\n            this.state = State.InDeclaration;\n        }\n    }\n    stateInSpecialComment(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeSpecialS(c) {\n        const lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        }\n        else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    }\n    stateBeforeSpecialT(c) {\n        const lower = c | 0x20;\n        switch (lower) {\n            case Sequences.TitleEnd[3]: {\n                this.startSpecial(Sequences.TitleEnd, 4);\n                break;\n            }\n            case Sequences.TextareaEnd[3]: {\n                this.startSpecial(Sequences.TextareaEnd, 4);\n                break;\n            }\n            case Sequences.XmpEnd[3]: {\n                this.startSpecial(Sequences.XmpEnd, 4);\n                break;\n            }\n            default: {\n                this.state = State.InTagName;\n                this.stateInTagName(c); // Consume the token again\n            }\n        }\n    }\n    startEntity() {\n        this.baseState = this.state;\n        this.state = State.InEntity;\n        this.entityStart = this.index;\n        this.entityDecoder.startEntity(this.xmlMode\n            ? entities_decode__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Strict\n            : this.baseState === State.Text ||\n                this.baseState === State.InSpecialTag\n                ? entities_decode__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Legacy\n                : entities_decode__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Attribute);\n    }\n    stateInEntity() {\n        const indexInBuffer = this.index - this.offset;\n        const length = this.entityDecoder.write(this.buffer, indexInBuffer);\n        // If `length` is positive, we are done with the entity.\n        if (length >= 0) {\n            this.state = this.baseState;\n            if (length === 0) {\n                this.index -= 1;\n            }\n        }\n        else {\n            if (indexInBuffer < this.buffer.length &&\n                this.buffer.charCodeAt(indexInBuffer) === CharCodes.Amp) {\n                this.state = this.baseState;\n                this.index -= 1;\n                return;\n            }\n            // Mark buffer as consumed.\n            this.index = this.offset + this.buffer.length - 1;\n        }\n    }\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    cleanup() {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n            else if (this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    }\n    shouldContinue() {\n        return this.index < this.buffer.length + this.offset && this.running;\n    }\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    parse() {\n        while (this.shouldContinue()) {\n            const c = this.buffer.charCodeAt(this.index - this.offset);\n            switch (this.state) {\n                case State.Text: {\n                    this.stateText(c);\n                    break;\n                }\n                case State.SpecialStartSequence: {\n                    this.stateSpecialStartSequence(c);\n                    break;\n                }\n                case State.InSpecialTag: {\n                    this.stateInSpecialTag(c);\n                    break;\n                }\n                case State.CDATASequence: {\n                    this.stateCDATASequence(c);\n                    break;\n                }\n                case State.InAttributeValueDq: {\n                    this.stateInAttributeValueDoubleQuotes(c);\n                    break;\n                }\n                case State.InAttributeName: {\n                    this.stateInAttributeName(c);\n                    break;\n                }\n                case State.InCommentLike: {\n                    this.stateInCommentLike(c);\n                    break;\n                }\n                case State.InSpecialComment: {\n                    this.stateInSpecialComment(c);\n                    break;\n                }\n                case State.BeforeAttributeName: {\n                    this.stateBeforeAttributeName(c);\n                    break;\n                }\n                case State.InTagName: {\n                    this.stateInTagName(c);\n                    break;\n                }\n                case State.InClosingTagName: {\n                    this.stateInClosingTagName(c);\n                    break;\n                }\n                case State.BeforeTagName: {\n                    this.stateBeforeTagName(c);\n                    break;\n                }\n                case State.AfterAttributeName: {\n                    this.stateAfterAttributeName(c);\n                    break;\n                }\n                case State.InAttributeValueSq: {\n                    this.stateInAttributeValueSingleQuotes(c);\n                    break;\n                }\n                case State.BeforeAttributeValue: {\n                    this.stateBeforeAttributeValue(c);\n                    break;\n                }\n                case State.BeforeClosingTagName: {\n                    this.stateBeforeClosingTagName(c);\n                    break;\n                }\n                case State.AfterClosingTagName: {\n                    this.stateAfterClosingTagName(c);\n                    break;\n                }\n                case State.BeforeSpecialS: {\n                    this.stateBeforeSpecialS(c);\n                    break;\n                }\n                case State.BeforeSpecialT: {\n                    this.stateBeforeSpecialT(c);\n                    break;\n                }\n                case State.InAttributeValueNq: {\n                    this.stateInAttributeValueNoQuotes(c);\n                    break;\n                }\n                case State.InSelfClosingTag: {\n                    this.stateInSelfClosingTag(c);\n                    break;\n                }\n                case State.InDeclaration: {\n                    this.stateInDeclaration(c);\n                    break;\n                }\n                case State.BeforeDeclaration: {\n                    this.stateBeforeDeclaration(c);\n                    break;\n                }\n                case State.BeforeComment: {\n                    this.stateBeforeComment(c);\n                    break;\n                }\n                case State.InProcessingInstruction: {\n                    this.stateInProcessingInstruction(c);\n                    break;\n                }\n                case State.InEntity: {\n                    this.stateInEntity();\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.cleanup();\n    }\n    finish() {\n        if (this.state === State.InEntity) {\n            this.entityDecoder.end();\n            this.state = this.baseState;\n        }\n        this.handleTrailingData();\n        this.cbs.onend();\n    }\n    /** Handle any trailing data. */\n    handleTrailingData() {\n        const endIndex = this.buffer.length + this.offset;\n        // If there is no remaining data, we are done.\n        if (this.sectionStart >= endIndex) {\n            return;\n        }\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            }\n            else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        }\n        else if (this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        }\n        else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    }\n    emitCodePoint(cp, consumed) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.onattribdata(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.onattribentity(cp);\n        }\n        else {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.ontext(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.ontextentity(cp, this.sectionStart);\n        }\n    }\n}\n//# sourceMappingURL=Tokenizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vVG9rZW5pemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZixrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQWEsV0FBVywwREFBYSxHQUFHLDJEQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBWTtBQUMxQjtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFZO0FBQzlCLGtCQUFrQix5REFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJjYWRlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vVG9rZW5pemVyLmpzPzQzOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW50aXR5RGVjb2RlciwgRGVjb2RpbmdNb2RlLCBodG1sRGVjb2RlVHJlZSwgeG1sRGVjb2RlVHJlZSwgfSBmcm9tIFwiZW50aXRpZXMvZGVjb2RlXCI7XG52YXIgQ2hhckNvZGVzO1xuKGZ1bmN0aW9uIChDaGFyQ29kZXMpIHtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVGFiXCJdID0gOV0gPSBcIlRhYlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJOZXdMaW5lXCJdID0gMTBdID0gXCJOZXdMaW5lXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkZvcm1GZWVkXCJdID0gMTJdID0gXCJGb3JtRmVlZFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJDYXJyaWFnZVJldHVyblwiXSA9IDEzXSA9IFwiQ2FycmlhZ2VSZXR1cm5cIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU3BhY2VcIl0gPSAzMl0gPSBcIlNwYWNlXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkV4Y2xhbWF0aW9uTWFya1wiXSA9IDMzXSA9IFwiRXhjbGFtYXRpb25NYXJrXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk51bWJlclwiXSA9IDM1XSA9IFwiTnVtYmVyXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkFtcFwiXSA9IDM4XSA9IFwiQW1wXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNpbmdsZVF1b3RlXCJdID0gMzldID0gXCJTaW5nbGVRdW90ZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJEb3VibGVRdW90ZVwiXSA9IDM0XSA9IFwiRG91YmxlUXVvdGVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRGFzaFwiXSA9IDQ1XSA9IFwiRGFzaFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTbGFzaFwiXSA9IDQ3XSA9IFwiU2xhc2hcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiWmVyb1wiXSA9IDQ4XSA9IFwiWmVyb1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJOaW5lXCJdID0gNTddID0gXCJOaW5lXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNlbWlcIl0gPSA1OV0gPSBcIlNlbWlcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTHRcIl0gPSA2MF0gPSBcIkx0XCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkVxXCJdID0gNjFdID0gXCJFcVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJHdFwiXSA9IDYyXSA9IFwiR3RcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiUXVlc3Rpb25tYXJrXCJdID0gNjNdID0gXCJRdWVzdGlvbm1hcmtcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVXBwZXJBXCJdID0gNjVdID0gXCJVcHBlckFcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTG93ZXJBXCJdID0gOTddID0gXCJMb3dlckFcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVXBwZXJGXCJdID0gNzBdID0gXCJVcHBlckZcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTG93ZXJGXCJdID0gMTAyXSA9IFwiTG93ZXJGXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVwcGVyWlwiXSA9IDkwXSA9IFwiVXBwZXJaXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxvd2VyWlwiXSA9IDEyMl0gPSBcIkxvd2VyWlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlclhcIl0gPSAxMjBdID0gXCJMb3dlclhcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiT3BlbmluZ1NxdWFyZUJyYWNrZXRcIl0gPSA5MV0gPSBcIk9wZW5pbmdTcXVhcmVCcmFja2V0XCI7XG59KShDaGFyQ29kZXMgfHwgKENoYXJDb2RlcyA9IHt9KSk7XG4vKiogQWxsIHRoZSBzdGF0ZXMgdGhlIHRva2VuaXplciBjYW4gYmUgaW4uICovXG52YXIgU3RhdGU7XG4oZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgU3RhdGVbU3RhdGVbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZVRhZ05hbWVcIl0gPSAyXSA9IFwiQmVmb3JlVGFnTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5UYWdOYW1lXCJdID0gM10gPSBcIkluVGFnTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5TZWxmQ2xvc2luZ1RhZ1wiXSA9IDRdID0gXCJJblNlbGZDbG9zaW5nVGFnXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVDbG9zaW5nVGFnTmFtZVwiXSA9IDVdID0gXCJCZWZvcmVDbG9zaW5nVGFnTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5DbG9zaW5nVGFnTmFtZVwiXSA9IDZdID0gXCJJbkNsb3NpbmdUYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJBZnRlckNsb3NpbmdUYWdOYW1lXCJdID0gN10gPSBcIkFmdGVyQ2xvc2luZ1RhZ05hbWVcIjtcbiAgICAvLyBBdHRyaWJ1dGVzXG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVBdHRyaWJ1dGVOYW1lXCJdID0gOF0gPSBcIkJlZm9yZUF0dHJpYnV0ZU5hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQXR0cmlidXRlTmFtZVwiXSA9IDldID0gXCJJbkF0dHJpYnV0ZU5hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkFmdGVyQXR0cmlidXRlTmFtZVwiXSA9IDEwXSA9IFwiQWZ0ZXJBdHRyaWJ1dGVOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVBdHRyaWJ1dGVWYWx1ZVwiXSA9IDExXSA9IFwiQmVmb3JlQXR0cmlidXRlVmFsdWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQXR0cmlidXRlVmFsdWVEcVwiXSA9IDEyXSA9IFwiSW5BdHRyaWJ1dGVWYWx1ZURxXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkF0dHJpYnV0ZVZhbHVlU3FcIl0gPSAxM10gPSBcIkluQXR0cmlidXRlVmFsdWVTcVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVWYWx1ZU5xXCJdID0gMTRdID0gXCJJbkF0dHJpYnV0ZVZhbHVlTnFcIjtcbiAgICAvLyBEZWNsYXJhdGlvbnNcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZURlY2xhcmF0aW9uXCJdID0gMTVdID0gXCJCZWZvcmVEZWNsYXJhdGlvblwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5EZWNsYXJhdGlvblwiXSA9IDE2XSA9IFwiSW5EZWNsYXJhdGlvblwiO1xuICAgIC8vIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgU3RhdGVbU3RhdGVbXCJJblByb2Nlc3NpbmdJbnN0cnVjdGlvblwiXSA9IDE3XSA9IFwiSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjtcbiAgICAvLyBDb21tZW50cyAmIENEQVRBXG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVDb21tZW50XCJdID0gMThdID0gXCJCZWZvcmVDb21tZW50XCI7XG4gICAgU3RhdGVbU3RhdGVbXCJDREFUQVNlcXVlbmNlXCJdID0gMTldID0gXCJDREFUQVNlcXVlbmNlXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblNwZWNpYWxDb21tZW50XCJdID0gMjBdID0gXCJJblNwZWNpYWxDb21tZW50XCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkNvbW1lbnRMaWtlXCJdID0gMjFdID0gXCJJbkNvbW1lbnRMaWtlXCI7XG4gICAgLy8gU3BlY2lhbCB0YWdzXG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVTcGVjaWFsU1wiXSA9IDIyXSA9IFwiQmVmb3JlU3BlY2lhbFNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZVNwZWNpYWxUXCJdID0gMjNdID0gXCJCZWZvcmVTcGVjaWFsVFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiU3BlY2lhbFN0YXJ0U2VxdWVuY2VcIl0gPSAyNF0gPSBcIlNwZWNpYWxTdGFydFNlcXVlbmNlXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblNwZWNpYWxUYWdcIl0gPSAyNV0gPSBcIkluU3BlY2lhbFRhZ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5FbnRpdHlcIl0gPSAyNl0gPSBcIkluRW50aXR5XCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgICByZXR1cm4gKGMgPT09IENoYXJDb2Rlcy5TcGFjZSB8fFxuICAgICAgICBjID09PSBDaGFyQ29kZXMuTmV3TGluZSB8fFxuICAgICAgICBjID09PSBDaGFyQ29kZXMuVGFiIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5Gb3JtRmVlZCB8fFxuICAgICAgICBjID09PSBDaGFyQ29kZXMuQ2FycmlhZ2VSZXR1cm4pO1xufVxuZnVuY3Rpb24gaXNFbmRPZlRhZ1NlY3Rpb24oYykge1xuICAgIHJldHVybiBjID09PSBDaGFyQ29kZXMuU2xhc2ggfHwgYyA9PT0gQ2hhckNvZGVzLkd0IHx8IGlzV2hpdGVzcGFjZShjKTtcbn1cbmZ1bmN0aW9uIGlzQVNDSUlBbHBoYShjKSB7XG4gICAgcmV0dXJuICgoYyA+PSBDaGFyQ29kZXMuTG93ZXJBICYmIGMgPD0gQ2hhckNvZGVzLkxvd2VyWikgfHxcbiAgICAgICAgKGMgPj0gQ2hhckNvZGVzLlVwcGVyQSAmJiBjIDw9IENoYXJDb2Rlcy5VcHBlclopKTtcbn1cbmV4cG9ydCB2YXIgUXVvdGVUeXBlO1xuKGZ1bmN0aW9uIChRdW90ZVR5cGUpIHtcbiAgICBRdW90ZVR5cGVbUXVvdGVUeXBlW1wiTm9WYWx1ZVwiXSA9IDBdID0gXCJOb1ZhbHVlXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIlVucXVvdGVkXCJdID0gMV0gPSBcIlVucXVvdGVkXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIlNpbmdsZVwiXSA9IDJdID0gXCJTaW5nbGVcIjtcbiAgICBRdW90ZVR5cGVbUXVvdGVUeXBlW1wiRG91YmxlXCJdID0gM10gPSBcIkRvdWJsZVwiO1xufSkoUXVvdGVUeXBlIHx8IChRdW90ZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBTZXF1ZW5jZXMgdXNlZCB0byBtYXRjaCBsb25nZXIgc3RyaW5ncy5cbiAqXG4gKiBXZSBkb24ndCBoYXZlIGBTY3JpcHRgLCBgU3R5bGVgLCBvciBgVGl0bGVgIGhlcmUuIEluc3RlYWQsIHdlIHJlLXVzZSB0aGUgKkVuZFxuICogc2VxdWVuY2VzIHdpdGggYW4gaW5jcmVhc2VkIG9mZnNldC5cbiAqL1xuY29uc3QgU2VxdWVuY2VzID0ge1xuICAgIENkYXRhOiBuZXcgVWludDhBcnJheShbMHg0MywgMHg0NCwgMHg0MSwgMHg1NCwgMHg0MSwgMHg1Yl0pLCAvLyBDREFUQVtcbiAgICBDZGF0YUVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4NWQsIDB4NWQsIDB4M2VdKSwgLy8gXV0+XG4gICAgQ29tbWVudEVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4MmQsIDB4MmQsIDB4M2VdKSwgLy8gYC0tPmBcbiAgICBTY3JpcHRFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDczLCAweDYzLCAweDcyLCAweDY5LCAweDcwLCAweDc0XSksIC8vIGA8L3NjcmlwdGBcbiAgICBTdHlsZUVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4M2MsIDB4MmYsIDB4NzMsIDB4NzQsIDB4NzksIDB4NmMsIDB4NjVdKSwgLy8gYDwvc3R5bGVgXG4gICAgVGl0bGVFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDc0LCAweDY5LCAweDc0LCAweDZjLCAweDY1XSksIC8vIGA8L3RpdGxlYFxuICAgIFRleHRhcmVhRW5kOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4M2MsIDB4MmYsIDB4NzQsIDB4NjUsIDB4NzgsIDB4NzQsIDB4NjEsIDB4NzIsIDB4NjUsIDB4NjEsXG4gICAgXSksIC8vIGA8L3RleHRhcmVhYFxuICAgIFhtcEVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4M2MsIDB4MmYsIDB4NzgsIDB4NmQsIDB4NzBdKSwgLy8gYDwveG1wYFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3IoeyB4bWxNb2RlID0gZmFsc2UsIGRlY29kZUVudGl0aWVzID0gdHJ1ZSwgfSwgY2JzKSB7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIC8qKiBUaGUgcmVhZCBidWZmZXIuICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgLyoqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC4gKi9cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICAvKiogVGhlIGluZGV4IHdpdGhpbiB0aGUgYnVmZmVyIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBsb29raW5nIGF0LiAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLyoqIFRoZSBzdGFydCBvZiB0aGUgbGFzdCBlbnRpdHkuICovXG4gICAgICAgIHRoaXMuZW50aXR5U3RhcnQgPSAwO1xuICAgICAgICAvKiogU29tZSBiZWhhdmlvciwgZWcuIHdoZW4gZGVjb2RpbmcgZW50aXRpZXMsIGlzIGRvbmUgd2hpbGUgd2UgYXJlIGluIGFub3RoZXIgc3RhdGUuIFRoaXMga2VlcHMgdHJhY2sgb2YgdGhlIG90aGVyIHN0YXRlIHR5cGUuICovXG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgLyoqIEZvciBzcGVjaWFsIHBhcnNpbmcgYmVoYXZpb3IgaW5zaWRlIG9mIHNjcmlwdCBhbmQgc3R5bGUgdGFncy4gKi9cbiAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbml6ZXIgaGFzIGJlZW4gcGF1c2VkLiAqL1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgY3VycmVudCBidWZmZXIuICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMueG1sTW9kZSA9IHhtbE1vZGU7XG4gICAgICAgIHRoaXMuZGVjb2RlRW50aXRpZXMgPSBkZWNvZGVFbnRpdGllcztcbiAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyID0gbmV3IEVudGl0eURlY29kZXIoeG1sTW9kZSA/IHhtbERlY29kZVRyZWUgOiBodG1sRGVjb2RlVHJlZSwgKGNwLCBjb25zdW1lZCkgPT4gdGhpcy5lbWl0Q29kZVBvaW50KGNwLCBjb25zdW1lZCkpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gY2h1bms7XG4gICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZVRleHQoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkx0IHx8XG4gICAgICAgICAgICAoIXRoaXMuZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5MdCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+IHRoaXMuc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVUYWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEVudGl0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlU3BlY2lhbFN0YXJ0U2VxdWVuY2UoYykge1xuICAgICAgICBjb25zdCBpc0VuZCA9IHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc01hdGNoID0gaXNFbmRcbiAgICAgICAgICAgID8gLy8gSWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBtYWtlIHN1cmUgdGhlIHRhZyBuYW1lIGhhcyBlbmRlZFxuICAgICAgICAgICAgICAgIGlzRW5kT2ZUYWdTZWN0aW9uKGMpXG4gICAgICAgICAgICA6IC8vIE90aGVyd2lzZSwgZG8gYSBjYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAoYyB8IDB4MjApID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdO1xuICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgIH1cbiAgICAvKiogTG9vayBmb3IgYW4gZW5kIHRhZy4gRm9yIDx0aXRsZT4gdGFncywgYWxzbyBkZWNvZGUgZW50aXRpZXMuICovXG4gICAgc3RhdGVJblNwZWNpYWxUYWcoYykge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kT2ZUZXh0ID0gdGhpcy5pbmRleCAtIHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCBlbmRPZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bvb2YgdGhlIGluZGV4IHNvIHRoYXQgcmVwb3J0ZWQgbG9jYXRpb25zIG1hdGNoIHVwLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBlbmRPZlRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kT2ZUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGFjdHVhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gZW5kT2ZUZXh0ICsgMjsgLy8gU2tpcCBvdmVyIHRoZSBgPC9gXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBhcmUgZG9uZTsgc2tpcCB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoYyB8IDB4MjApID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLlRpdGxlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBwYXJzZSBlbnRpdGllcyBpbiA8dGl0bGU+IHRhZ3MuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW50aXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5MdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdXRzaWRlIG9mIDx0aXRsZT4gdGFncywgd2UgY2FuIGZhc3QtZm9yd2FyZC5cbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2Ugc2VlIGEgYDxgLCBzZXQgdGhlIHNlcXVlbmNlIGluZGV4IHRvIDE7IHVzZWZ1bCBmb3IgZWcuIGA8PC9zY3JpcHQ+YC5cbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IE51bWJlcihjID09PSBDaGFyQ29kZXMuTHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQ0RBVEFTZXF1ZW5jZShjKSB7XG4gICAgICAgIGlmIChjID09PSBTZXF1ZW5jZXMuQ2RhdGFbdGhpcy5zZXF1ZW5jZUluZGV4XSkge1xuICAgICAgICAgICAgaWYgKCsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSBTZXF1ZW5jZXMuQ2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQ29tbWVudExpa2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBTZXF1ZW5jZXMuQ2RhdGFFbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUluRGVjbGFyYXRpb24oYyk7IC8vIFJlY29uc3VtZSB0aGUgY2hhcmFjdGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXG4gICAgICogYnkgc2tpcHBpbmcgdGhyb3VnaCB0aGUgYnVmZmVyIHVudGlsIHdlIGZpbmQgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIGZhc3RGb3J3YXJkVG8oYykge1xuICAgICAgICB3aGlsZSAoKyt0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMuaW5kZXggLSB0aGlzLm9mZnNldCkgPT09IGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBpbmNyZW1lbnQgdGhlIGluZGV4IGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZWAgbG9vcCxcbiAgICAgICAgICogc28gc2V0IGl0IHRvIGBidWZmZXIubGVuZ3RoIC0gMWAgaGVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogUmVmYWN0b3IgYHBhcnNlYCB0byBpbmNyZW1lbnQgaW5kZXggYmVmb3JlIGNhbGxpbmcgc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0IC0gMTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21tZW50cyBhbmQgQ0RBVEEgZW5kIHdpdGggYC0tPmAgYW5kIGBdXT5gLlxuICAgICAqXG4gICAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XG4gICAgICogLSBUaGVpciBlbmQgc2VxdWVuY2VzIGhhdmUgYSBkaXN0aW5jdCBjaGFyYWN0ZXIgdGhleSBzdGFydCB3aXRoLlxuICAgICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxuICAgICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIHN0YXRlSW5Db21tZW50TGlrZShjKSB7XG4gICAgICAgIGlmIChjID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4LCAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRmFzdC1mb3J3YXJkIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICBpZiAodGhpcy5mYXN0Rm9yd2FyZFRvKHRoaXMuY3VycmVudFNlcXVlbmNlWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4IC0gMV0pIHtcbiAgICAgICAgICAgIC8vIEFsbG93IGxvbmcgc2VxdWVuY2VzLCBlZy4gLS0tPiwgXV1dPlxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIVE1MIG9ubHkgYWxsb3dzIEFTQ0lJIGFscGhhIGNoYXJhY3RlcnMgKGEteiBhbmQgQS1aKSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBYTUwgYWxsb3dzIGEgbG90IG1vcmUgY2hhcmFjdGVycyBoZXJlIChAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyKS5cbiAgICAgKiBXZSBhbGxvdyBhbnl0aGluZyB0aGF0IHdvdWxkbid0IGVuZCB0aGUgdGFnLlxuICAgICAqL1xuICAgIGlzVGFnU3RhcnRDaGFyKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueG1sTW9kZSA/ICFpc0VuZE9mVGFnU2VjdGlvbihjKSA6IGlzQVNDSUlBbHBoYShjKTtcbiAgICB9XG4gICAgc3RhcnRTcGVjaWFsKHNlcXVlbmNlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHNlcXVlbmNlO1xuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TcGVjaWFsU3RhcnRTZXF1ZW5jZTtcbiAgICB9XG4gICAgc3RhdGVCZWZvcmVUYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FeGNsYW1hdGlvbk1hcmspIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlF1ZXN0aW9ubWFyaykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVGFnU3RhcnRDaGFyKGMpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVTcGVjaWFsUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VyID09PSBTZXF1ZW5jZXMuVGl0bGVFbmRbMl0gfHxcbiAgICAgICAgICAgICAgICBsb3dlciA9PT0gU2VxdWVuY2VzLlhtcEVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVTcGVjaWFsVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQ2xvc2luZ1RhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5UYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWduYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoYykge1xuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaXNUYWdTdGFydENoYXIoYylcbiAgICAgICAgICAgICAgICA/IFN0YXRlLkluQ2xvc2luZ1RhZ05hbWVcbiAgICAgICAgICAgICAgICA6IFN0YXRlLkluU3BlY2lhbENvbW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5BZnRlckNsb3NpbmdUYWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpIHtcbiAgICAgICAgLy8gU2tpcCBldmVyeXRoaW5nIHVudGlsIFwiPlwiXG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWdlbmQodGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TcGVjaWFsVGFnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TZWxmQ2xvc2luZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uc2VsZmNsb3Npbmd0YWcodGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IGZhbHNlOyAvLyBSZXNldCBzcGVjaWFsIHN0YXRlLCBpbiBjYXNlIG9mIHNlbGYtY2xvc2luZyBzcGVjaWFsIHRhZ3NcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FcSB8fCBpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJuYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5BZnRlckF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FcSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TbGFzaCB8fCBjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFF1b3RlVHlwZS5Ob1ZhbHVlLCB0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChRdW90ZVR5cGUuTm9WYWx1ZSwgdGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5Eb3VibGVRdW90ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNpbmdsZVF1b3RlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZVNxO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZU5xO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyhjKTsgLy8gUmVjb25zdW1lIHRva2VuXG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlSW5BdHRyaWJ1dGVWYWx1ZShjLCBxdW90ZSkge1xuICAgICAgICBpZiAoYyA9PT0gcXVvdGUgfHxcbiAgICAgICAgICAgICghdGhpcy5kZWNvZGVFbnRpdGllcyAmJiB0aGlzLmZhc3RGb3J3YXJkVG8ocXVvdGUpKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChxdW90ZSA9PT0gQ2hhckNvZGVzLkRvdWJsZVF1b3RlXG4gICAgICAgICAgICAgICAgPyBRdW90ZVR5cGUuRG91YmxlXG4gICAgICAgICAgICAgICAgOiBRdW90ZVR5cGUuU2luZ2xlLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IENoYXJDb2Rlcy5BbXApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbnRpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMoYykge1xuICAgICAgICB0aGlzLmhhbmRsZUluQXR0cmlidXRlVmFsdWUoYywgQ2hhckNvZGVzLkRvdWJsZVF1b3RlKTtcbiAgICB9XG4gICAgc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlKGMsIENoYXJDb2Rlcy5TaW5nbGVRdW90ZSk7XG4gICAgfVxuICAgIHN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpIHtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSB8fCBjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoUXVvdGVUeXBlLlVucXVvdGVkLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW50aXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuT3BlbmluZ1NxdWFyZUJyYWNrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5DREFUQVNlcXVlbmNlO1xuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPVxuICAgICAgICAgICAgICAgIGMgPT09IENoYXJDb2Rlcy5EYXNoXG4gICAgICAgICAgICAgICAgICAgID8gU3RhdGUuQmVmb3JlQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICA6IFN0YXRlLkluRGVjbGFyYXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJbkRlY2xhcmF0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkd0KSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25kZWNsYXJhdGlvbih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUNvbW1lbnQoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkRhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkNvbW1lbnRMaWtlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBTZXF1ZW5jZXMuQ29tbWVudEVuZDtcbiAgICAgICAgICAgIC8vIEFsbG93IHNob3J0IGNvbW1lbnRzIChlZy4gPCEtLT4pXG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAyO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5TcGVjaWFsQ29tbWVudChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCwgMCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVCZWZvcmVTcGVjaWFsUyhjKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyID0gYyB8IDB4MjA7XG4gICAgICAgIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlNjcmlwdEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG93ZXIgPT09IFNlcXVlbmNlcy5TdHlsZUVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlN0eWxlRW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpOyAvLyBDb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQmVmb3JlU3BlY2lhbFQoYykge1xuICAgICAgICBjb25zdCBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5UaXRsZUVuZFszXToge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5UaXRsZUVuZCwgNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5UZXh0YXJlYUVuZFszXToge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5UZXh0YXJlYUVuZCwgNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5YbXBFbmRbM106IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuWG1wRW5kLCA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRFbnRpdHkoKSB7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRW50aXR5O1xuICAgICAgICB0aGlzLmVudGl0eVN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyLnN0YXJ0RW50aXR5KHRoaXMueG1sTW9kZVxuICAgICAgICAgICAgPyBEZWNvZGluZ01vZGUuU3RyaWN0XG4gICAgICAgICAgICA6IHRoaXMuYmFzZVN0YXRlID09PSBTdGF0ZS5UZXh0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPT09IFN0YXRlLkluU3BlY2lhbFRhZ1xuICAgICAgICAgICAgICAgID8gRGVjb2RpbmdNb2RlLkxlZ2FjeVxuICAgICAgICAgICAgICAgIDogRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHN0YXRlSW5FbnRpdHkoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4SW5CdWZmZXIgPSB0aGlzLmluZGV4IC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZW50aXR5RGVjb2Rlci53cml0ZSh0aGlzLmJ1ZmZlciwgaW5kZXhJbkJ1ZmZlcik7XG4gICAgICAgIC8vIElmIGBsZW5ndGhgIGlzIHBvc2l0aXZlLCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBlbnRpdHkuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRleEluQnVmZmVyIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuY2hhckNvZGVBdChpbmRleEluQnVmZmVyKSA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayBidWZmZXIgYXMgY29uc3VtZWQuXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5vZmZzZXQgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBkYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZCBmcm9tIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBvZiB0ZXh0IG9yIGF0dHJpYnV0ZXMsIGVtaXQgd2hhdCB3ZSBhbHJlYWR5IGhhdmUuXG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcgJiYgdGhpcy5zZWN0aW9uU3RhcnQgIT09IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5UZXh0IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluU3BlY2lhbFRhZyAmJiB0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlRHEgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3EgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlTnEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRDb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLm9mZnNldCAmJiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFN0YXRlcyB0aGF0IGFyZSBtb3JlIGxpa2VseSB0byBiZSBoaXQgYXJlIGhpZ2hlciB1cCwgYXMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC5cbiAgICAgKi9cbiAgICBwYXJzZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuVGV4dDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVGV4dChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuU3BlY2lhbFN0YXJ0U2VxdWVuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVNwZWNpYWxTdGFydFNlcXVlbmNlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblNwZWNpYWxUYWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluU3BlY2lhbFRhZyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQ0RBVEFTZXF1ZW5jZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ0RBVEFTZXF1ZW5jZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZURxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5Db21tZW50TGlrZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5Db21tZW50TGlrZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5TcGVjaWFsQ29tbWVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TcGVjaWFsQ29tbWVudChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5UYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQ2xvc2luZ1RhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZVRhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkFmdGVyQXR0cmlidXRlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3E6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUF0dHJpYnV0ZVZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQ2xvc2luZ1RhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5BZnRlckNsb3NpbmdUYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVTcGVjaWFsUzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbFMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZVNwZWNpYWxUOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsVChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZU5xOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlTm9RdW90ZXMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluU2VsZkNsb3NpbmdUYWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluU2VsZkNsb3NpbmdUYWcoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluRGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZURlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQ29tbWVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ29tbWVudChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkVudGl0eToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5FbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkVudGl0eSkge1xuICAgICAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhaWxpbmdEYXRhKCk7XG4gICAgICAgIHRoaXMuY2JzLm9uZW5kKCk7XG4gICAgfVxuICAgIC8qKiBIYW5kbGUgYW55IHRyYWlsaW5nIGRhdGEuICovXG4gICAgaGFuZGxlVHJhaWxpbmdEYXRhKCkge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyByZW1haW5pbmcgZGF0YSwgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA+PSBlbmRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkNvbW1lbnRMaWtlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5DZGF0YUVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIGVuZEluZGV4LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluVGFnTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQmVmb3JlQXR0cmlidXRlVmFsdWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkFmdGVyQXR0cmlidXRlTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3EgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZU5xIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkNsb3NpbmdUYWdOYW1lKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhbiBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnLCB1cyBub3QgY2FsbGluZyB0aGVcbiAgICAgICAgICAgICAqIHJlc3BlY3RpdmUgY2FsbGJhY2sgc2lnbmFscyB0aGF0IHRoZSB0YWcgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRDb2RlUG9pbnQoY3AsIGNvbnN1bWVkKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTdGF0ZSAhPT0gU3RhdGUuVGV4dCAmJlxuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgIT09IFN0YXRlLkluU3BlY2lhbFRhZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgdGhpcy5lbnRpdHlTdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5lbnRpdHlTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuZW50aXR5U3RhcnQgKyBjb25zdW1lZDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnNlY3Rpb25TdGFydCAtIDE7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVudGl0eShjcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLmVudGl0eVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmVudGl0eVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5lbnRpdHlTdGFydCArIGNvbnN1bWVkO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc2VjdGlvblN0YXJ0IC0gMTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dGVudGl0eShjcCwgdGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5pemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/dist/esm/Tokenizer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/dist/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/htmlparser2/dist/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultHandler: () => (/* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler),\n/* harmony export */   DomHandler: () => (/* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler),\n/* harmony export */   DomUtils: () => (/* reexport module object */ domutils__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   ElementType: () => (/* reexport module object */ domelementtype__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   Parser: () => (/* reexport safe */ _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser),\n/* harmony export */   QuoteType: () => (/* reexport safe */ _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__.QuoteType),\n/* harmony export */   Tokenizer: () => (/* reexport safe */ _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   createDocumentStream: () => (/* binding */ createDocumentStream),\n/* harmony export */   createDomStream: () => (/* binding */ createDomStream),\n/* harmony export */   getFeed: () => (/* reexport safe */ domutils__WEBPACK_IMPORTED_MODULE_4__.getFeed),\n/* harmony export */   parseDOM: () => (/* binding */ parseDOM),\n/* harmony export */   parseDocument: () => (/* binding */ parseDocument),\n/* harmony export */   parseFeed: () => (/* binding */ parseFeed)\n/* harmony export */ });\n/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Parser.js */ \"(rsc)/./node_modules/htmlparser2/dist/esm/Parser.js\");\n/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! domhandler */ \"(rsc)/./node_modules/domhandler/lib/esm/index.js\");\n/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tokenizer.js */ \"(rsc)/./node_modules/htmlparser2/dist/esm/Tokenizer.js\");\n/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! domelementtype */ \"(rsc)/./node_modules/domelementtype/lib/esm/index.js\");\n/* harmony import */ var domutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! domutils */ \"(rsc)/./node_modules/domutils/lib/esm/index.js\");\n\n\n\n\n// Helper methods\n/**\n * Parses the data, returns the resulting document.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n */\nfunction parseDocument(data, options) {\n    const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler(undefined, options);\n    new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options).end(data);\n    return handler.root;\n}\n/**\n * Parses data, returns an array of the root nodes.\n *\n * Note that the root nodes still have a `Document` node as their parent.\n * Use `parseDocument` to get the `Document` node instead.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n * @deprecated Use `parseDocument` instead.\n */\nfunction parseDOM(data, options) {\n    return parseDocument(data, options).children;\n}\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with the resulting document.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n */\nfunction createDocumentStream(callback, options, elementCallback) {\n    const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler((error) => callback(error, handler.root), options, elementCallback);\n    return new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options);\n}\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n * @deprecated Use `createDocumentStream` instead.\n */\nfunction createDomStream(callback, options, elementCallback) {\n    const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler(callback, options, elementCallback);\n    return new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options);\n}\n\n/*\n * All of the following exports exist for backwards-compatibility.\n * They should probably be removed eventually.\n */\n\n\n\nconst parseFeedDefaultOptions = { xmlMode: true };\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options = parseFeedDefaultOptions) {\n    return (0,domutils__WEBPACK_IMPORTED_MODULE_4__.getFeed)(parseDOM(feed, options));\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0E7QUFDSTtBQUdTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0Isa0RBQVU7QUFDbEMsUUFBUSw4Q0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0Isa0RBQVU7QUFDbEMsZUFBZSw4Q0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdCQUF3QixrREFBVTtBQUNsQyxlQUFlLDhDQUFNO0FBQ3JCO0FBQ2tFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQ1g7QUFDQTtBQUNuQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGlEQUFPO0FBQ2xCO0FBQ3FDO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJjYWRlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9lc20vaW5kZXguanM/YmNjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9QYXJzZXIuanNcIjtcbmV4cG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL1BhcnNlci5qc1wiO1xuaW1wb3J0IHsgRG9tSGFuZGxlciwgfSBmcm9tIFwiZG9taGFuZGxlclwiO1xuZXhwb3J0IHsgRG9tSGFuZGxlciwgXG4vLyBPbGQgbmFtZSBmb3IgRG9tSGFuZGxlclxuRG9tSGFuZGxlciBhcyBEZWZhdWx0SGFuZGxlciwgfSBmcm9tIFwiZG9taGFuZGxlclwiO1xuLy8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIHRoZSBkYXRhLCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURvY3VtZW50KGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IERvbUhhbmRsZXIodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBuZXcgUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChkYXRhKTtcbiAgICByZXR1cm4gaGFuZGxlci5yb290O1xufVxuLyoqXG4gKiBQYXJzZXMgZGF0YSwgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcm9vdCBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJvb3Qgbm9kZXMgc3RpbGwgaGF2ZSBhIGBEb2N1bWVudGAgbm9kZSBhcyB0aGVpciBwYXJlbnQuXG4gKiBVc2UgYHBhcnNlRG9jdW1lbnRgIHRvIGdldCB0aGUgYERvY3VtZW50YCBub2RlIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHBhcnNlRG9jdW1lbnRgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURPTShkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBhcnNlRG9jdW1lbnQoZGF0YSwgb3B0aW9ucykuY2hpbGRyZW47XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgaW5zdGFuY2UsIHdpdGggYW4gYXR0YWNoZWQgRE9NIGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIHBhcnNpbmcgaGFzIGJlZW4gY29tcGxldGVkLCB3aXRoIHRoZSByZXN1bHRpbmcgZG9jdW1lbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gaGFuZGxlci5cbiAqIEBwYXJhbSBlbGVtZW50Q2FsbGJhY2sgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIGEgdGFnIGhhcyBiZWVuIGNvbXBsZXRlZCBpbnNpZGUgb2YgdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50U3RyZWFtKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spIHtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IERvbUhhbmRsZXIoKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvciwgaGFuZGxlci5yb290KSwgb3B0aW9ucywgZWxlbWVudENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBpbnN0YW5jZSwgd2l0aCBhbiBhdHRhY2hlZCBET00gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQsIHdpdGggYW4gYXJyYXkgb2Ygcm9vdCBub2Rlcy5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIgYW5kIERPTSBoYW5kbGVyLlxuICogQHBhcmFtIGVsZW1lbnRDYWxsYmFjayBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSB0YWcgaGFzIGJlZW4gY29tcGxldGVkIGluc2lkZSBvZiB0aGUgRE9NLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBjcmVhdGVEb2N1bWVudFN0cmVhbWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURvbVN0cmVhbShjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBEb21IYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spO1xuICAgIHJldHVybiBuZXcgUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb2tlbml6ZXIsIFF1b3RlVHlwZSwgfSBmcm9tIFwiLi9Ub2tlbml6ZXIuanNcIjtcbi8qXG4gKiBBbGwgb2YgdGhlIGZvbGxvd2luZyBleHBvcnRzIGV4aXN0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqIFRoZXkgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgZXZlbnR1YWxseS5cbiAqL1xuZXhwb3J0ICogYXMgRWxlbWVudFR5cGUgZnJvbSBcImRvbWVsZW1lbnR0eXBlXCI7XG5pbXBvcnQgeyBnZXRGZWVkIH0gZnJvbSBcImRvbXV0aWxzXCI7XG5leHBvcnQgeyBnZXRGZWVkIH0gZnJvbSBcImRvbXV0aWxzXCI7XG5jb25zdCBwYXJzZUZlZWREZWZhdWx0T3B0aW9ucyA9IHsgeG1sTW9kZTogdHJ1ZSB9O1xuLyoqXG4gKiBQYXJzZSBhIGZlZWQuXG4gKlxuICogQHBhcmFtIGZlZWQgVGhlIGZlZWQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLCBhcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsbHksIG9wdGlvbnMgZm9yIHBhcnNpbmcuIFdoZW4gdXNpbmcgdGhpcywgeW91IHNob3VsZCBzZXQgYHhtbE1vZGVgIHRvIGB0cnVlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmVlZChmZWVkLCBvcHRpb25zID0gcGFyc2VGZWVkRGVmYXVsdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0RmVlZChwYXJzZURPTShmZWVkLCBvcHRpb25zKSk7XG59XG5leHBvcnQgKiBhcyBEb21VdGlscyBmcm9tIFwiZG9tdXRpbHNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode-codepoint.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/decode-codepoint.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeCodePoint: () => (/* binding */ decodeCodePoint),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint),\n/* harmony export */   replaceCodePoint: () => (/* binding */ replaceCodePoint)\n/* harmony export */ });\n// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134\nvar _a;\nconst decodeMap = new Map([\n    [0, 65533],\n    // C1 Unicode control character reference replacements\n    [128, 8364],\n    [130, 8218],\n    [131, 402],\n    [132, 8222],\n    [133, 8230],\n    [134, 8224],\n    [135, 8225],\n    [136, 710],\n    [137, 8240],\n    [138, 352],\n    [139, 8249],\n    [140, 338],\n    [142, 381],\n    [145, 8216],\n    [146, 8217],\n    [147, 8220],\n    [148, 8221],\n    [149, 8226],\n    [150, 8211],\n    [151, 8212],\n    [152, 732],\n    [153, 8482],\n    [154, 353],\n    [155, 8250],\n    [156, 339],\n    [158, 382],\n    [159, 376],\n]);\n/**\n * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.\n */\nconst fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins\n(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : ((codePoint) => {\n    let output = \"\";\n    if (codePoint > 65535) {\n        codePoint -= 65536;\n        output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);\n        codePoint = 56320 | (codePoint & 1023);\n    }\n    output += String.fromCharCode(codePoint);\n    return output;\n});\n/**\n * Replace the given code point with a replacement character if it is a\n * surrogate or is outside the valid range. Otherwise return the code\n * point unchanged.\n */\nfunction replaceCodePoint(codePoint) {\n    var _a;\n    if ((codePoint >= 55296 && codePoint <= 57343) ||\n        codePoint > 1114111) {\n        return 65533;\n    }\n    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;\n}\n/**\n * Replace the code point if relevant, then convert it to a string.\n *\n * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.\n * @param codePoint The code point to decode.\n * @returns The decoded code point.\n */\nfunction decodeCodePoint(codePoint) {\n    return fromCodePoint(replaceCodePoint(codePoint));\n}\n//# sourceMappingURL=decode-codepoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2RlY29kZS1jb2RlcG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcmNhZGUtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZW50aXRpZXMvZGlzdC9lc20vZGVjb2RlLWNvZGVwb2ludC5qcz9lNjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iLzM2YWZlMTc5MzkyMjI2Y2YxYjZjY2RiMTZlYmJiN2E1YTg0NGQ5M2Evc3JjL2hlLmpzI0wxMDYtTDEzNFxudmFyIF9hO1xuY29uc3QgZGVjb2RlTWFwID0gbmV3IE1hcChbXG4gICAgWzAsIDY1NTMzXSxcbiAgICAvLyBDMSBVbmljb2RlIGNvbnRyb2wgY2hhcmFjdGVyIHJlZmVyZW5jZSByZXBsYWNlbWVudHNcbiAgICBbMTI4LCA4MzY0XSxcbiAgICBbMTMwLCA4MjE4XSxcbiAgICBbMTMxLCA0MDJdLFxuICAgIFsxMzIsIDgyMjJdLFxuICAgIFsxMzMsIDgyMzBdLFxuICAgIFsxMzQsIDgyMjRdLFxuICAgIFsxMzUsIDgyMjVdLFxuICAgIFsxMzYsIDcxMF0sXG4gICAgWzEzNywgODI0MF0sXG4gICAgWzEzOCwgMzUyXSxcbiAgICBbMTM5LCA4MjQ5XSxcbiAgICBbMTQwLCAzMzhdLFxuICAgIFsxNDIsIDM4MV0sXG4gICAgWzE0NSwgODIxNl0sXG4gICAgWzE0NiwgODIxN10sXG4gICAgWzE0NywgODIyMF0sXG4gICAgWzE0OCwgODIyMV0sXG4gICAgWzE0OSwgODIyNl0sXG4gICAgWzE1MCwgODIxMV0sXG4gICAgWzE1MSwgODIxMl0sXG4gICAgWzE1MiwgNzMyXSxcbiAgICBbMTUzLCA4NDgyXSxcbiAgICBbMTU0LCAzNTNdLFxuICAgIFsxNTUsIDgyNTBdLFxuICAgIFsxNTYsIDMzOV0sXG4gICAgWzE1OCwgMzgyXSxcbiAgICBbMTU5LCAzNzZdLFxuXSk7XG4vKipcbiAqIFBvbHlmaWxsIGZvciBgU3RyaW5nLmZyb21Db2RlUG9pbnRgLiBJdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHN0cmluZyBmcm9tIGEgVW5pY29kZSBjb2RlIHBvaW50LlxuICovXG5leHBvcnQgY29uc3QgZnJvbUNvZGVQb2ludCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIG4vbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvZXMtYnVpbHRpbnNcbihfYSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKGNvZGVQb2ludCkgPT4ge1xuICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkge1xuICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+PiAxMCkgJiAxMDIzKSB8IDU1Mjk2KTtcbiAgICAgICAgY29kZVBvaW50ID0gNTYzMjAgfCAoY29kZVBvaW50ICYgMTAyMyk7XG4gICAgfVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn0pO1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBnaXZlbiBjb2RlIHBvaW50IHdpdGggYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaWYgaXQgaXMgYVxuICogc3Vycm9nYXRlIG9yIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlLiBPdGhlcndpc2UgcmV0dXJuIHRoZSBjb2RlXG4gKiBwb2ludCB1bmNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKGNvZGVQb2ludCA+PSA1NTI5NiAmJiBjb2RlUG9pbnQgPD0gNTczNDMpIHx8XG4gICAgICAgIGNvZGVQb2ludCA+IDExMTQxMTEpIHtcbiAgICAgICAgcmV0dXJuIDY1NTMzO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gZGVjb2RlTWFwLmdldChjb2RlUG9pbnQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2RlUG9pbnQ7XG59XG4vKipcbiAqIFJlcGxhY2UgdGhlIGNvZGUgcG9pbnQgaWYgcmVsZXZhbnQsIHRoZW4gY29udmVydCBpdCB0byBhIHN0cmluZy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGZyb21Db2RlUG9pbnQocmVwbGFjZUNvZGVQb2ludChjb2RlUG9pbnQpKWAgaW5zdGVhZC5cbiAqIEBwYXJhbSBjb2RlUG9pbnQgVGhlIGNvZGUgcG9pbnQgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgY29kZSBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChyZXBsYWNlQ29kZVBvaW50KGNvZGVQb2ludCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLWNvZGVwb2ludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode-codepoint.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/decode.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodingMode: () => (/* binding */ DecodingMode),\n/* harmony export */   EntityDecoder: () => (/* binding */ EntityDecoder),\n/* harmony export */   decodeCodePoint: () => (/* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__.decodeCodePoint),\n/* harmony export */   decodeHTML: () => (/* binding */ decodeHTML),\n/* harmony export */   decodeHTMLAttribute: () => (/* binding */ decodeHTMLAttribute),\n/* harmony export */   decodeHTMLStrict: () => (/* binding */ decodeHTMLStrict),\n/* harmony export */   decodeXML: () => (/* binding */ decodeXML),\n/* harmony export */   determineBranch: () => (/* binding */ determineBranch),\n/* harmony export */   fromCodePoint: () => (/* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__.fromCodePoint),\n/* harmony export */   htmlDecodeTree: () => (/* reexport safe */ _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_1__.htmlDecodeTree),\n/* harmony export */   replaceCodePoint: () => (/* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__.replaceCodePoint),\n/* harmony export */   xmlDecodeTree: () => (/* reexport safe */ _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_2__.xmlDecodeTree)\n/* harmony export */ });\n/* harmony import */ var _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decode-codepoint.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode-codepoint.js\");\n/* harmony import */ var _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generated/decode-data-html.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-html.js\");\n/* harmony import */ var _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generated/decode-data-xml.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-xml.js\");\n/* harmony import */ var _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bin-trie-flags.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/bin-trie-flags.js\");\n\n\n\n\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n    CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n    CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n    CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 32;\nfunction isNumber(code) {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));\n}\nfunction isAsciiAlphaNumeric(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code));\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n    EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n    EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n    EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nvar DecodingMode;\n(function (DecodingMode) {\n    /** Entities in text nodes that can end with any character. */\n    DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n    /** Only allow entities terminated with a semicolon. */\n    DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n    /** Entities in attributes have limitations on ending characters. */\n    DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode || (DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nclass EntityDecoder {\n    constructor(\n    /** The tree used to decode entities. */\n    // biome-ignore lint/correctness/noUnusedPrivateClassMembers: False positive\n    decodeTree, \n    /**\n     * The function that is called when a codepoint is decoded.\n     *\n     * For multi-byte named entities, this will be called multiple times,\n     * with the second codepoint, and the same `consumed` value.\n     *\n     * @param codepoint The decoded codepoint.\n     * @param consumed The number of bytes consumed by the decoder.\n     */\n    emitCodePoint, \n    /** An object that is used to produce errors. */\n    errors) {\n        this.decodeTree = decodeTree;\n        this.emitCodePoint = emitCodePoint;\n        this.errors = errors;\n        /** The current state of the decoder. */\n        this.state = EntityDecoderState.EntityStart;\n        /** Characters that were consumed while parsing an entity. */\n        this.consumed = 1;\n        /**\n         * The result of the entity.\n         *\n         * Either the result index of a numeric entity, or the codepoint of a\n         * numeric entity.\n         */\n        this.result = 0;\n        /** The current index in the decode tree. */\n        this.treeIndex = 0;\n        /** The number of characters that were consumed in excess. */\n        this.excess = 1;\n        /** The mode in which the decoder is operating. */\n        this.decodeMode = DecodingMode.Strict;\n        /** The number of characters that have been consumed in the current run. */\n        this.runConsumed = 0;\n    }\n    /** Resets the instance to make it reusable. */\n    startEntity(decodeMode) {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n        this.runConsumed = 0;\n    }\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    write(input, offset) {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (input.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(input, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(input, offset);\n            }\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(input, offset);\n            }\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(input, offset);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(input, offset);\n            }\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(input, offset);\n            }\n        }\n    }\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericStart(input, offset) {\n        if (offset >= input.length) {\n            return -1;\n        }\n        if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(input, offset + 1);\n        }\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(input, offset);\n    }\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericHex(input, offset) {\n        while (offset < input.length) {\n            const char = input.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                // Convert hex digit to value (0-15); 'a'/'A' -> 10.\n                const digit = char <= CharCodes.NINE\n                    ? char - CharCodes.ZERO\n                    : (char | TO_LOWER_BIT) - CharCodes.LOWER_A + 10;\n                this.result = this.result * 16 + digit;\n                this.consumed++;\n                offset++;\n            }\n            else {\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n        return -1; // Incomplete entity\n    }\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericDecimal(input, offset) {\n        while (offset < input.length) {\n            const char = input.charCodeAt(offset);\n            if (isNumber(char)) {\n                this.result = this.result * 10 + (char - CharCodes.ZERO);\n                this.consumed++;\n                offset++;\n            }\n            else {\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n        return -1; // Incomplete entity\n    }\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    emitNumericEntity(lastCp, expectedLength) {\n        var _a;\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n            return 0;\n        }\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        }\n        else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n        this.emitCodePoint((0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__.replaceCodePoint)(this.result), this.consumed);\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n        return this.consumed;\n    }\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param input The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNamedEntity(input, offset) {\n        const { decodeTree } = this;\n        let current = decodeTree[this.treeIndex];\n        // The length is the number of bytes of the value, including the current byte.\n        let valueLength = (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.VALUE_LENGTH) >> 14;\n        while (offset < input.length) {\n            // Handle compact runs (possibly inline): valueLength == 0 and SEMI_REQUIRED bit set.\n            if (valueLength === 0 && (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.FLAG13) !== 0) {\n                const runLength = (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.BRANCH_LENGTH) >> 7; /* 2..63 */\n                // If we are starting a run, check the first char.\n                if (this.runConsumed === 0) {\n                    const firstChar = current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.JUMP_TABLE;\n                    if (input.charCodeAt(offset) !== firstChar) {\n                        return this.result === 0\n                            ? 0\n                            : this.emitNotTerminatedNamedEntity();\n                    }\n                    offset++;\n                    this.excess++;\n                    this.runConsumed++;\n                }\n                // Check remaining characters in the run.\n                while (this.runConsumed < runLength) {\n                    if (offset >= input.length) {\n                        return -1;\n                    }\n                    const charIndexInPacked = this.runConsumed - 1;\n                    const packedWord = decodeTree[this.treeIndex + 1 + (charIndexInPacked >> 1)];\n                    const expectedChar = charIndexInPacked % 2 === 0\n                        ? packedWord & 0xff\n                        : (packedWord >> 8) & 0xff;\n                    if (input.charCodeAt(offset) !== expectedChar) {\n                        this.runConsumed = 0;\n                        return this.result === 0\n                            ? 0\n                            : this.emitNotTerminatedNamedEntity();\n                    }\n                    offset++;\n                    this.excess++;\n                    this.runConsumed++;\n                }\n                this.runConsumed = 0;\n                this.treeIndex += 1 + (runLength >> 1);\n                current = decodeTree[this.treeIndex];\n                valueLength = (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.VALUE_LENGTH) >> 14;\n            }\n            if (offset >= input.length)\n                break;\n            const char = input.charCodeAt(offset);\n            /*\n             * Implicit semicolon handling for nodes that require a semicolon but\n             * don't have an explicit ';' branch stored in the trie. If we have\n             * a value on the current node, it requires a semicolon, and the\n             * current input character is a semicolon, emit the entity using the\n             * current node (without descending further).\n             */\n            if (char === CharCodes.SEMI &&\n                valueLength !== 0 &&\n                (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.FLAG13) !== 0) {\n                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n            }\n            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.VALUE_LENGTH) >> 14;\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n                }\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict &&\n                    (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.FLAG13) === 0) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n            // Increment offset & excess for next iteration\n            offset++;\n            this.excess++;\n        }\n        return -1;\n    }\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNotTerminatedNamedEntity() {\n        var _a;\n        const { result, decodeTree } = this;\n        const valueLength = (decodeTree[result] & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.VALUE_LENGTH) >> 14;\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n        return this.consumed;\n    }\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNamedEntityData(result, valueLength, consumed) {\n        const { decodeTree } = this;\n        this.emitCodePoint(valueLength === 1\n            ? decodeTree[result] &\n                ~(_internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.VALUE_LENGTH | _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.FLAG13)\n            : decodeTree[result + 1], consumed);\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n        return consumed;\n    }\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    end() {\n        var _a;\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    }\n}\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n    let returnValue = \"\";\n    const decoder = new EntityDecoder(decodeTree, (data) => (returnValue += (0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_0__.fromCodePoint)(data)));\n    return function decodeWithTrie(input, decodeMode) {\n        let lastIndex = 0;\n        let offset = 0;\n        while ((offset = input.indexOf(\"&\", offset)) >= 0) {\n            returnValue += input.slice(lastIndex, offset);\n            decoder.startEntity(decodeMode);\n            const length = decoder.write(input, \n            // Skip the \"&\"\n            offset + 1);\n            if (length < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n            lastIndex = offset + length;\n            // If `length` is 0, skip the current `&` and continue.\n            offset = length === 0 ? lastIndex + 1 : lastIndex;\n        }\n        const result = returnValue + input.slice(lastIndex);\n        // Make sure we don't keep a reference to the final string.\n        returnValue = \"\";\n        return result;\n    };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nfunction determineBranch(decodeTree, current, nodeIndex, char) {\n    const branchCount = (current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.BRANCH_LENGTH) >> 7;\n    const jumpOffset = current & _internal_bin_trie_flags_js__WEBPACK_IMPORTED_MODULE_3__.BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        const value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIndex + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in packed dictionary (two keys per uint16)\n    const packedKeySlots = (branchCount + 1) >> 1;\n    /*\n     * Treat packed keys as a virtual sorted array of length `branchCount`.\n     * Key(i) = low byte for even i, high byte for odd i in slot i>>1.\n     */\n    let lo = 0;\n    let hi = branchCount - 1;\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const slot = mid >> 1;\n        const packed = decodeTree[nodeIndex + slot];\n        const midKey = (packed >> ((mid & 1) * 8)) & 0xff;\n        if (midKey < char) {\n            lo = mid + 1;\n        }\n        else if (midKey > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[nodeIndex + packedKeySlots + mid];\n        }\n    }\n    return -1;\n}\nconst htmlDecoder = /* #__PURE__ */ getDecoder(_generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_1__.htmlDecodeTree);\nconst xmlDecoder = /* #__PURE__ */ getDecoder(_generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_2__.xmlDecodeTree);\n/**\n * Decodes an HTML string.\n *\n * @param htmlString The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nfunction decodeHTML(htmlString, mode = DecodingMode.Legacy) {\n    return htmlDecoder(htmlString, mode);\n}\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param htmlAttribute The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLAttribute(htmlAttribute) {\n    return htmlDecoder(htmlAttribute, DecodingMode.Attribute);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param htmlString The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLStrict(htmlString) {\n    return htmlDecoder(htmlString, DecodingMode.Strict);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param xmlString The string to decode.\n * @returns The decoded string.\n */\nfunction decodeXML(xmlString) {\n    return xmlDecoder(xmlString, DecodingMode.Strict);\n}\n\n// Re-export for use by eg. htmlparser2\n\n\n//# sourceMappingURL=decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2RlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdFO0FBQ1A7QUFDRjtBQUNIO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQ0FBbUMscUVBQVk7QUFDL0MsaUNBQWlDLHFFQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwRUFBYztBQUM3RCw4Q0FBOEMsd0VBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDMEY7QUFDMUY7QUFDaUU7QUFDRjtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FyY2FkZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9lbnRpdGllcy9kaXN0L2VzbS9kZWNvZGUuanM/ZWMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tQ29kZVBvaW50LCByZXBsYWNlQ29kZVBvaW50IH0gZnJvbSBcIi4vZGVjb2RlLWNvZGVwb2ludC5qc1wiO1xuaW1wb3J0IHsgaHRtbERlY29kZVRyZWUgfSBmcm9tIFwiLi9nZW5lcmF0ZWQvZGVjb2RlLWRhdGEtaHRtbC5qc1wiO1xuaW1wb3J0IHsgeG1sRGVjb2RlVHJlZSB9IGZyb20gXCIuL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS14bWwuanNcIjtcbmltcG9ydCB7IEJpblRyaWVGbGFncyB9IGZyb20gXCIuL2ludGVybmFsL2Jpbi10cmllLWZsYWdzLmpzXCI7XG52YXIgQ2hhckNvZGVzO1xuKGZ1bmN0aW9uIChDaGFyQ29kZXMpIHtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTlVNXCJdID0gMzVdID0gXCJOVU1cIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU0VNSVwiXSA9IDU5XSA9IFwiU0VNSVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJFUVVBTFNcIl0gPSA2MV0gPSBcIkVRVUFMU1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJaRVJPXCJdID0gNDhdID0gXCJaRVJPXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5JTkVcIl0gPSA1N10gPSBcIk5JTkVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTE9XRVJfQVwiXSA9IDk3XSA9IFwiTE9XRVJfQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMT1dFUl9GXCJdID0gMTAyXSA9IFwiTE9XRVJfRlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMT1dFUl9YXCJdID0gMTIwXSA9IFwiTE9XRVJfWFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMT1dFUl9aXCJdID0gMTIyXSA9IFwiTE9XRVJfWlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVUFBFUl9BXCJdID0gNjVdID0gXCJVUFBFUl9BXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVQUEVSX0ZcIl0gPSA3MF0gPSBcIlVQUEVSX0ZcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVVBQRVJfWlwiXSA9IDkwXSA9IFwiVVBQRVJfWlwiO1xufSkoQ2hhckNvZGVzIHx8IChDaGFyQ29kZXMgPSB7fSkpO1xuLyoqIEJpdCB0aGF0IG5lZWRzIHRvIGJlIHNldCB0byBjb252ZXJ0IGFuIHVwcGVyIGNhc2UgQVNDSUkgY2hhcmFjdGVyIHRvIGxvd2VyIGNhc2UgKi9cbmNvbnN0IFRPX0xPV0VSX0JJVCA9IDMyO1xuZnVuY3Rpb24gaXNOdW1iZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IENoYXJDb2Rlcy5aRVJPICYmIGNvZGUgPD0gQ2hhckNvZGVzLk5JTkU7XG59XG5mdW5jdGlvbiBpc0hleGFkZWNpbWFsQ2hhcmFjdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gKChjb2RlID49IENoYXJDb2Rlcy5VUFBFUl9BICYmIGNvZGUgPD0gQ2hhckNvZGVzLlVQUEVSX0YpIHx8XG4gICAgICAgIChjb2RlID49IENoYXJDb2Rlcy5MT1dFUl9BICYmIGNvZGUgPD0gQ2hhckNvZGVzLkxPV0VSX0YpKTtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlBbHBoYU51bWVyaWMoY29kZSkge1xuICAgIHJldHVybiAoKGNvZGUgPj0gQ2hhckNvZGVzLlVQUEVSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuVVBQRVJfWikgfHxcbiAgICAgICAgKGNvZGUgPj0gQ2hhckNvZGVzLkxPV0VSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuTE9XRVJfWikgfHxcbiAgICAgICAgaXNOdW1iZXIoY29kZSkpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNoYXJhY3RlciBpcyBhIHZhbGlkIGVuZCBjaGFyYWN0ZXIgZm9yIGFuIGVudGl0eSBpbiBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQXR0cmlidXRlIHZhbHVlcyB0aGF0IGFyZW4ndCB0ZXJtaW5hdGVkIHByb3Blcmx5IGFyZW4ndCBwYXJzZWQsIGFuZCBzaG91bGRuJ3QgbGVhZCB0byBhIHBhcnNlciBlcnJvci5cbiAqIFNlZSB0aGUgZXhhbXBsZSBpbiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZS1zdGF0ZVxuICovXG5mdW5jdGlvbiBpc0VudGl0eUluQXR0cmlidXRlSW52YWxpZEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IENoYXJDb2Rlcy5FUVVBTFMgfHwgaXNBc2NpaUFscGhhTnVtZXJpYyhjb2RlKTtcbn1cbnZhciBFbnRpdHlEZWNvZGVyU3RhdGU7XG4oZnVuY3Rpb24gKEVudGl0eURlY29kZXJTdGF0ZSkge1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJFbnRpdHlTdGFydFwiXSA9IDBdID0gXCJFbnRpdHlTdGFydFwiO1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJOdW1lcmljU3RhcnRcIl0gPSAxXSA9IFwiTnVtZXJpY1N0YXJ0XCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk51bWVyaWNEZWNpbWFsXCJdID0gMl0gPSBcIk51bWVyaWNEZWNpbWFsXCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk51bWVyaWNIZXhcIl0gPSAzXSA9IFwiTnVtZXJpY0hleFwiO1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJOYW1lZEVudGl0eVwiXSA9IDRdID0gXCJOYW1lZEVudGl0eVwiO1xufSkoRW50aXR5RGVjb2RlclN0YXRlIHx8IChFbnRpdHlEZWNvZGVyU3RhdGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWNvZGluZ01vZGU7XG4oZnVuY3Rpb24gKERlY29kaW5nTW9kZSkge1xuICAgIC8qKiBFbnRpdGllcyBpbiB0ZXh0IG5vZGVzIHRoYXQgY2FuIGVuZCB3aXRoIGFueSBjaGFyYWN0ZXIuICovXG4gICAgRGVjb2RpbmdNb2RlW0RlY29kaW5nTW9kZVtcIkxlZ2FjeVwiXSA9IDBdID0gXCJMZWdhY3lcIjtcbiAgICAvKiogT25seSBhbGxvdyBlbnRpdGllcyB0ZXJtaW5hdGVkIHdpdGggYSBzZW1pY29sb24uICovXG4gICAgRGVjb2RpbmdNb2RlW0RlY29kaW5nTW9kZVtcIlN0cmljdFwiXSA9IDFdID0gXCJTdHJpY3RcIjtcbiAgICAvKiogRW50aXRpZXMgaW4gYXR0cmlidXRlcyBoYXZlIGxpbWl0YXRpb25zIG9uIGVuZGluZyBjaGFyYWN0ZXJzLiAqL1xuICAgIERlY29kaW5nTW9kZVtEZWNvZGluZ01vZGVbXCJBdHRyaWJ1dGVcIl0gPSAyXSA9IFwiQXR0cmlidXRlXCI7XG59KShEZWNvZGluZ01vZGUgfHwgKERlY29kaW5nTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRva2VuIGRlY29kZXIgd2l0aCBzdXBwb3J0IG9mIHdyaXRpbmcgcGFydGlhbCBlbnRpdGllcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudGl0eURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHJlZSB1c2VkIHRvIGRlY29kZSBlbnRpdGllcy4gKi9cbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy9ub1VudXNlZFByaXZhdGVDbGFzc01lbWJlcnM6IEZhbHNlIHBvc2l0aXZlXG4gICAgZGVjb2RlVHJlZSwgXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBjb2RlcG9pbnQgaXMgZGVjb2RlZC5cbiAgICAgKlxuICAgICAqIEZvciBtdWx0aS1ieXRlIG5hbWVkIGVudGl0aWVzLCB0aGlzIHdpbGwgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLFxuICAgICAqIHdpdGggdGhlIHNlY29uZCBjb2RlcG9pbnQsIGFuZCB0aGUgc2FtZSBgY29uc3VtZWRgIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGVwb2ludCBUaGUgZGVjb2RlZCBjb2RlcG9pbnQuXG4gICAgICogQHBhcmFtIGNvbnN1bWVkIFRoZSBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGRlY29kZXIuXG4gICAgICovXG4gICAgZW1pdENvZGVQb2ludCwgXG4gICAgLyoqIEFuIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gcHJvZHVjZSBlcnJvcnMuICovXG4gICAgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlVHJlZSA9IGRlY29kZVRyZWU7XG4gICAgICAgIHRoaXMuZW1pdENvZGVQb2ludCA9IGVtaXRDb2RlUG9pbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRlY29kZXIuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuRW50aXR5U3RhcnQ7XG4gICAgICAgIC8qKiBDaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCB3aGlsZSBwYXJzaW5nIGFuIGVudGl0eS4gKi9cbiAgICAgICAgdGhpcy5jb25zdW1lZCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBlbnRpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVpdGhlciB0aGUgcmVzdWx0IGluZGV4IG9mIGEgbnVtZXJpYyBlbnRpdHksIG9yIHRoZSBjb2RlcG9pbnQgb2YgYVxuICAgICAgICAgKiBudW1lcmljIGVudGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdWx0ID0gMDtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBkZWNvZGUgdHJlZS4gKi9cbiAgICAgICAgdGhpcy50cmVlSW5kZXggPSAwO1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCBpbiBleGNlc3MuICovXG4gICAgICAgIHRoaXMuZXhjZXNzID0gMTtcbiAgICAgICAgLyoqIFRoZSBtb2RlIGluIHdoaWNoIHRoZSBkZWNvZGVyIGlzIG9wZXJhdGluZy4gKi9cbiAgICAgICAgdGhpcy5kZWNvZGVNb2RlID0gRGVjb2RpbmdNb2RlLlN0cmljdDtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiBjb25zdW1lZCBpbiB0aGUgY3VycmVudCBydW4uICovXG4gICAgICAgIHRoaXMucnVuQ29uc3VtZWQgPSAwO1xuICAgIH1cbiAgICAvKiogUmVzZXRzIHRoZSBpbnN0YW5jZSB0byBtYWtlIGl0IHJldXNhYmxlLiAqL1xuICAgIHN0YXJ0RW50aXR5KGRlY29kZU1vZGUpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVNb2RlID0gZGVjb2RlTW9kZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSAwO1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZXhjZXNzID0gMTtcbiAgICAgICAgdGhpcy5jb25zdW1lZCA9IDE7XG4gICAgICAgIHRoaXMucnVuQ29uc3VtZWQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhbiBlbnRpdHkgdG8gdGhlIGRlY29kZXIuIFRoaXMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHBhcnRpYWwgZW50aXRpZXMuXG4gICAgICogSWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLCB0aGUgZGVjb2RlciB3aWxsIHJldHVybiAtMS5cbiAgICAgKlxuICAgICAqIE1pcnJvcnMgdGhlIGltcGxlbWVudGF0aW9uIG9mIGBnZXREZWNvZGVyYCwgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gc3RvcCBkZWNvZGluZyBpZiB0aGVcbiAgICAgKiBlbnRpdHkgaXMgaW5jb21wbGV0ZSwgYW5kIHJlc3VtZSB3aGVuIHRoZSBuZXh0IHN0cmluZyBpcyB3cml0dGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgZW50aXR5IChvciBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgZW50aXR5KS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVudGl0eSBiZWdpbnMuIFNob3VsZCBiZSAwIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBjYWxsLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICB3cml0ZShpbnB1dCwgb2Zmc2V0KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuRW50aXR5U3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChvZmZzZXQpID09PSBDaGFyQ29kZXMuTlVNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY1N0YXJ0KGlucHV0LCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5OYW1lZEVudGl0eTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU5hbWVkRW50aXR5KGlucHV0LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY1N0YXJ0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1lcmljU3RhcnQoaW5wdXQsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljRGVjaW1hbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0RlY2ltYWwoaW5wdXQsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljSGV4OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1lcmljSGV4KGlucHV0LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTmFtZWRFbnRpdHk6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU5hbWVkRW50aXR5KGlucHV0LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIGJldHdlZW4gdGhlIG51bWVyaWMgZGVjaW1hbCBhbmQgaGV4YWRlY2ltYWwgc3RhdGVzLlxuICAgICAqXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgYE51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgY3VycmVudCBvZmZzZXQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCwgb3IgLTEgaWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIHN0YXRlTnVtZXJpY1N0YXJ0KGlucHV0LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSB8IFRPX0xPV0VSX0JJVCkgPT09IENoYXJDb2Rlcy5MT1dFUl9YKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNIZXg7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWVyaWNIZXgoaW5wdXQsIG9mZnNldCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0RlY2ltYWw7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0RlY2ltYWwoaW5wdXQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGhleGFkZWNpbWFsIG51bWVyaWMgZW50aXR5LlxuICAgICAqXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgYEhleGFkZW1pY2FsIGNoYXJhY3RlciByZWZlcmVuY2Ugc3RhdGVgIGluIHRoZSBIVE1MIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpdHkgKG9yIGEgY29udGludWF0aW9uIG9mIHRoZSBlbnRpdHkpLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICBzdGF0ZU51bWVyaWNIZXgoaW5wdXQsIG9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaW5wdXQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGNoYXIpIHx8IGlzSGV4YWRlY2ltYWxDaGFyYWN0ZXIoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGhleCBkaWdpdCB0byB2YWx1ZSAoMC0xNSk7ICdhJy8nQScgLT4gMTAuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBjaGFyIDw9IENoYXJDb2Rlcy5OSU5FXG4gICAgICAgICAgICAgICAgICAgID8gY2hhciAtIENoYXJDb2Rlcy5aRVJPXG4gICAgICAgICAgICAgICAgICAgIDogKGNoYXIgfCBUT19MT1dFUl9CSVQpIC0gQ2hhckNvZGVzLkxPV0VSX0EgKyAxMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMucmVzdWx0ICogMTYgKyBkaWdpdDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVkKys7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eShjaGFyLCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7IC8vIEluY29tcGxldGUgZW50aXR5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGRlY2ltYWwgbnVtZXJpYyBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgRGVjaW1hbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHN0YXRlYCBpbiB0aGUgSFRNTCBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgZW50aXR5IChvciBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgZW50aXR5KS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBjdXJyZW50IG9mZnNldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkLCBvciAtMSBpZiB0aGUgZW50aXR5IGlzIGluY29tcGxldGUuXG4gICAgICovXG4gICAgc3RhdGVOdW1lcmljRGVjaW1hbChpbnB1dCwgb2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoY2hhcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMucmVzdWx0ICogMTAgKyAoY2hhciAtIENoYXJDb2Rlcy5aRVJPKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVkKys7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eShjaGFyLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7IC8vIEluY29tcGxldGUgZW50aXR5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGFuZCBlbWl0IGEgbnVtZXJpYyBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBsb2dpYyBmcm9tIHRoZSBgSGV4YWRlbWljYWwgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGFydFxuICAgICAqIHN0YXRlYCBhbmQgYE51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZSBlbmQgc3RhdGVgIGluIHRoZSBIVE1MIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFzdENwIFRoZSBsYXN0IGNvZGUgcG9pbnQgb2YgdGhlIGVudGl0eS4gVXNlZCB0byBzZWUgaWYgdGhlXG4gICAgICogICAgICAgICAgICAgICBlbnRpdHkgd2FzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvbi5cbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggVGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQuIFVzZWQgdG8gdmFsaWRhdGUgdGhhdCBhdCBsZWFzdCBvbmUgZGlnaXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2FzIGNvbnN1bWVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQuXG4gICAgICovXG4gICAgZW1pdE51bWVyaWNFbnRpdHkobGFzdENwLCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBjb25zdW1lZCBhdCBsZWFzdCBvbmUgZGlnaXQuXG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVkIDw9IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmVycm9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFic2VuY2VPZkRpZ2l0c0luTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSh0aGlzLmNvbnN1bWVkKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBhIGxlZ2l0IGVuZCBvZiB0aGUgZW50aXR5XG4gICAgICAgIGlmIChsYXN0Q3AgPT09IENoYXJDb2Rlcy5TRU1JKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVNb2RlID09PSBEZWNvZGluZ01vZGUuU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRDb2RlUG9pbnQocmVwbGFjZUNvZGVQb2ludCh0aGlzLnJlc3VsdCksIHRoaXMuY29uc3VtZWQpO1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0Q3AgIT09IENoYXJDb2Rlcy5TRU1JKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMubWlzc2luZ1NlbWljb2xvbkFmdGVyQ2hhcmFjdGVyUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9ycy52YWxpZGF0ZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UodGhpcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBuYW1lZCBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgTmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgY3VycmVudCBvZmZzZXQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCwgb3IgLTEgaWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIHN0YXRlTmFtZWRFbnRpdHkoaW5wdXQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB7IGRlY29kZVRyZWUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjdXJyZW50ID0gZGVjb2RlVHJlZVt0aGlzLnRyZWVJbmRleF07XG4gICAgICAgIC8vIFRoZSBsZW5ndGggaXMgdGhlIG51bWJlciBvZiBieXRlcyBvZiB0aGUgdmFsdWUsIGluY2x1ZGluZyB0aGUgY3VycmVudCBieXRlLlxuICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSAoY3VycmVudCAmIEJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEgpID4+IDE0O1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY29tcGFjdCBydW5zIChwb3NzaWJseSBpbmxpbmUpOiB2YWx1ZUxlbmd0aCA9PSAwIGFuZCBTRU1JX1JFUVVJUkVEIGJpdCBzZXQuXG4gICAgICAgICAgICBpZiAodmFsdWVMZW5ndGggPT09IDAgJiYgKGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuRkxBRzEzKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bkxlbmd0aCA9IChjdXJyZW50ICYgQmluVHJpZUZsYWdzLkJSQU5DSF9MRU5HVEgpID4+IDc7IC8qIDIuLjYzICovXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHN0YXJ0aW5nIGEgcnVuLCBjaGVjayB0aGUgZmlyc3QgY2hhci5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5Db25zdW1lZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENoYXIgPSBjdXJyZW50ICYgQmluVHJpZUZsYWdzLkpVTVBfVEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KG9mZnNldCkgIT09IGZpcnN0Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmVtaXROb3RUZXJtaW5hdGVkTmFtZWRFbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGNlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Db25zdW1lZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayByZW1haW5pbmcgY2hhcmFjdGVycyBpbiB0aGUgcnVuLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnJ1bkNvbnN1bWVkIDwgcnVuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckluZGV4SW5QYWNrZWQgPSB0aGlzLnJ1bkNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFja2VkV29yZCA9IGRlY29kZVRyZWVbdGhpcy50cmVlSW5kZXggKyAxICsgKGNoYXJJbmRleEluUGFja2VkID4+IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDaGFyID0gY2hhckluZGV4SW5QYWNrZWQgJSAyID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhY2tlZFdvcmQgJiAweGZmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChwYWNrZWRXb3JkID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSAhPT0gZXhwZWN0ZWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkNvbnN1bWVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbWl0Tm90VGVybWluYXRlZE5hbWVkRW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhjZXNzKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuQ29uc3VtZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5Db25zdW1lZCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlSW5kZXggKz0gMSArIChydW5MZW5ndGggPj4gMSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGRlY29kZVRyZWVbdGhpcy50cmVlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gKGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuVkFMVUVfTEVOR1RIKSA+PiAxNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gaW5wdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJbXBsaWNpdCBzZW1pY29sb24gaGFuZGxpbmcgZm9yIG5vZGVzIHRoYXQgcmVxdWlyZSBhIHNlbWljb2xvbiBidXRcbiAgICAgICAgICAgICAqIGRvbid0IGhhdmUgYW4gZXhwbGljaXQgJzsnIGJyYW5jaCBzdG9yZWQgaW4gdGhlIHRyaWUuIElmIHdlIGhhdmVcbiAgICAgICAgICAgICAqIGEgdmFsdWUgb24gdGhlIGN1cnJlbnQgbm9kZSwgaXQgcmVxdWlyZXMgYSBzZW1pY29sb24sIGFuZCB0aGVcbiAgICAgICAgICAgICAqIGN1cnJlbnQgaW5wdXQgY2hhcmFjdGVyIGlzIGEgc2VtaWNvbG9uLCBlbWl0IHRoZSBlbnRpdHkgdXNpbmcgdGhlXG4gICAgICAgICAgICAgKiBjdXJyZW50IG5vZGUgKHdpdGhvdXQgZGVzY2VuZGluZyBmdXJ0aGVyKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09IENoYXJDb2Rlcy5TRU1JICYmXG4gICAgICAgICAgICAgICAgdmFsdWVMZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmIEJpblRyaWVGbGFncy5GTEFHMTMpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE5hbWVkRW50aXR5RGF0YSh0aGlzLnRyZWVJbmRleCwgdmFsdWVMZW5ndGgsIHRoaXMuY29uc3VtZWQgKyB0aGlzLmV4Y2Vzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVJbmRleCA9IGRldGVybWluZUJyYW5jaChkZWNvZGVUcmVlLCBjdXJyZW50LCB0aGlzLnRyZWVJbmRleCArIE1hdGgubWF4KDEsIHZhbHVlTGVuZ3RoKSwgY2hhcik7XG4gICAgICAgICAgICBpZiAodGhpcy50cmVlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBwYXJzaW5nIGFuIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kZWNvZGVNb2RlID09PSBEZWNvZGluZ01vZGUuQXR0cmlidXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGRuJ3QgaGF2ZSBjb25zdW1lZCBhbnkgY2hhcmFjdGVycyBhZnRlciB0aGUgZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlTGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHRoZXJlIHNob3VsZCBiZSBubyBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFbnRpdHlJbkF0dHJpYnV0ZUludmFsaWRFbmQoY2hhcikpKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmVtaXROb3RUZXJtaW5hdGVkTmFtZWRFbnRpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBkZWNvZGVUcmVlW3RoaXMudHJlZUluZGV4XTtcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gKGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuVkFMVUVfTEVOR1RIKSA+PiAxNDtcbiAgICAgICAgICAgIC8vIElmIHRoZSBicmFuY2ggaXMgYSB2YWx1ZSwgc3RvcmUgaXQgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAodmFsdWVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW50aXR5IGlzIHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24sIHdlIGFyZSBkb25lLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBDaGFyQ29kZXMuU0VNSSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TmFtZWRFbnRpdHlEYXRhKHRoaXMudHJlZUluZGV4LCB2YWx1ZUxlbmd0aCwgdGhpcy5jb25zdW1lZCArIHRoaXMuZXhjZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgbm9uLXRlcm1pbmF0ZWQgKGxlZ2FjeSkgZW50aXR5IHdoaWxlIHBhcnNpbmcgc3RyaWN0bHksIHRoZW4gaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZU1vZGUgIT09IERlY29kaW5nTW9kZS5TdHJpY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuRkxBRzEzKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMudHJlZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IHRoaXMuZXhjZXNzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4Y2VzcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IG9mZnNldCAmIGV4Y2VzcyBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgdGhpcy5leGNlc3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYSBuYW1lZCBlbnRpdHkgdGhhdCB3YXMgbm90IHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKi9cbiAgICBlbWl0Tm90VGVybWluYXRlZE5hbWVkRW50aXR5KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCBkZWNvZGVUcmVlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB2YWx1ZUxlbmd0aCA9IChkZWNvZGVUcmVlW3Jlc3VsdF0gJiBCaW5UcmllRmxhZ3MuVkFMVUVfTEVOR1RIKSA+PiAxNDtcbiAgICAgICAgdGhpcy5lbWl0TmFtZWRFbnRpdHlEYXRhKHJlc3VsdCwgdmFsdWVMZW5ndGgsIHRoaXMuY29uc3VtZWQpO1xuICAgICAgICAoX2EgPSB0aGlzLmVycm9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1pc3NpbmdTZW1pY29sb25BZnRlckNoYXJhY3RlclJlZmVyZW5jZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhIG5hbWVkIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgVGhlIGluZGV4IG9mIHRoZSBlbnRpdHkgaW4gdGhlIGRlY29kZSB0cmVlLlxuICAgICAqIEBwYXJhbSB2YWx1ZUxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBlbnRpdHkuXG4gICAgICogQHBhcmFtIGNvbnN1bWVkIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKi9cbiAgICBlbWl0TmFtZWRFbnRpdHlEYXRhKHJlc3VsdCwgdmFsdWVMZW5ndGgsIGNvbnN1bWVkKSB7XG4gICAgICAgIGNvbnN0IHsgZGVjb2RlVHJlZSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50KHZhbHVlTGVuZ3RoID09PSAxXG4gICAgICAgICAgICA/IGRlY29kZVRyZWVbcmVzdWx0XSAmXG4gICAgICAgICAgICAgICAgfihCaW5UcmllRmxhZ3MuVkFMVUVfTEVOR1RIIHwgQmluVHJpZUZsYWdzLkZMQUcxMylcbiAgICAgICAgICAgIDogZGVjb2RlVHJlZVtyZXN1bHQgKyAxXSwgY29uc3VtZWQpO1xuICAgICAgICBpZiAodmFsdWVMZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEZvciBtdWx0aS1ieXRlIHZhbHVlcywgd2UgbmVlZCB0byBlbWl0IHRoZSBzZWNvbmQgYnl0ZS5cbiAgICAgICAgICAgIHRoaXMuZW1pdENvZGVQb2ludChkZWNvZGVUcmVlW3Jlc3VsdCArIDJdLCBjb25zdW1lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgdG8gdGhlIHBhcnNlciB0aGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IHdhcyByZWFjaGVkLlxuICAgICAqXG4gICAgICogUmVtYWluaW5nIGRhdGEgd2lsbCBiZSBlbWl0dGVkIGFuZCByZWxldmFudCBlcnJvcnMgd2lsbCBiZSBwcm9kdWNlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OYW1lZEVudGl0eToge1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBuYW1lZCBlbnRpdHkgaWYgd2UgaGF2ZSBvbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0ICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29kZU1vZGUgIT09IERlY29kaW5nTW9kZS5BdHRyaWJ1dGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID09PSB0aGlzLnRyZWVJbmRleClcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmVtaXROb3RUZXJtaW5hdGVkTmFtZWRFbnRpdHkoKVxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGVtaXQgYSBudW1lcmljIGVudGl0eSBpZiB3ZSBoYXZlIG9uZS5cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNEZWNpbWFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE51bWVyaWNFbnRpdHkoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljSGV4OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE51bWVyaWNFbnRpdHkoMCwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljU3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmVycm9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFic2VuY2VPZkRpZ2l0c0luTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSh0aGlzLmNvbnN1bWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLkVudGl0eVN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIDAgaWYgd2UgaGF2ZSBubyBlbnRpdHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGRlY29kZXMgZW50aXRpZXMgaW4gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGRlY29kZVRyZWUgVGhlIGRlY29kZSB0cmVlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGRlY29kZXMgZW50aXRpZXMgaW4gYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldERlY29kZXIoZGVjb2RlVHJlZSkge1xuICAgIGxldCByZXR1cm5WYWx1ZSA9IFwiXCI7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBFbnRpdHlEZWNvZGVyKGRlY29kZVRyZWUsIChkYXRhKSA9PiAocmV0dXJuVmFsdWUgKz0gZnJvbUNvZGVQb2ludChkYXRhKSkpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvZGVXaXRoVHJpZShpbnB1dCwgZGVjb2RlTW9kZSkge1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlICgob2Zmc2V0ID0gaW5wdXQuaW5kZXhPZihcIiZcIiwgb2Zmc2V0KSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgKz0gaW5wdXQuc2xpY2UobGFzdEluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgZGVjb2Rlci5zdGFydEVudGl0eShkZWNvZGVNb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGRlY29kZXIud3JpdGUoaW5wdXQsIFxuICAgICAgICAgICAgLy8gU2tpcCB0aGUgXCImXCJcbiAgICAgICAgICAgIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBvZmZzZXQgKyBkZWNvZGVyLmVuZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluZGV4ID0gb2Zmc2V0ICsgbGVuZ3RoO1xuICAgICAgICAgICAgLy8gSWYgYGxlbmd0aGAgaXMgMCwgc2tpcCB0aGUgY3VycmVudCBgJmAgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoID09PSAwID8gbGFzdEluZGV4ICsgMSA6IGxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSByZXR1cm5WYWx1ZSArIGlucHV0LnNsaWNlKGxhc3RJbmRleCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAgIHJldHVyblZhbHVlID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBicmFuY2ggb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IGlzIHRha2VuIGdpdmVuIHRoZSBjdXJyZW50XG4gKiBjaGFyYWN0ZXIuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgdHJpZS5cbiAqXG4gKiBAcGFyYW0gZGVjb2RlVHJlZSBUaGUgdHJpZS5cbiAqIEBwYXJhbSBjdXJyZW50IFRoZSBjdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0gbm9kZUlkeCBUaGUgaW5kZXggcmlnaHQgYWZ0ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgaXRzIHZhbHVlLlxuICogQHBhcmFtIGNoYXIgVGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBuZXh0IG5vZGUsIG9yIC0xIGlmIG5vIGJyYW5jaCBpcyB0YWtlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUJyYW5jaChkZWNvZGVUcmVlLCBjdXJyZW50LCBub2RlSW5kZXgsIGNoYXIpIHtcbiAgICBjb25zdCBicmFuY2hDb3VudCA9IChjdXJyZW50ICYgQmluVHJpZUZsYWdzLkJSQU5DSF9MRU5HVEgpID4+IDc7XG4gICAgY29uc3QganVtcE9mZnNldCA9IGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuSlVNUF9UQUJMRTtcbiAgICAvLyBDYXNlIDE6IFNpbmdsZSBicmFuY2ggZW5jb2RlZCBpbiBqdW1wIG9mZnNldFxuICAgIGlmIChicmFuY2hDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ganVtcE9mZnNldCAhPT0gMCAmJiBjaGFyID09PSBqdW1wT2Zmc2V0ID8gbm9kZUluZGV4IDogLTE7XG4gICAgfVxuICAgIC8vIENhc2UgMjogTXVsdGlwbGUgYnJhbmNoZXMgZW5jb2RlZCBpbiBqdW1wIHRhYmxlXG4gICAgaWYgKGp1bXBPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFyIC0ganVtcE9mZnNldDtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSBicmFuY2hDb3VudFxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiBkZWNvZGVUcmVlW25vZGVJbmRleCArIHZhbHVlXSAtIDE7XG4gICAgfVxuICAgIC8vIENhc2UgMzogTXVsdGlwbGUgYnJhbmNoZXMgZW5jb2RlZCBpbiBwYWNrZWQgZGljdGlvbmFyeSAodHdvIGtleXMgcGVyIHVpbnQxNilcbiAgICBjb25zdCBwYWNrZWRLZXlTbG90cyA9IChicmFuY2hDb3VudCArIDEpID4+IDE7XG4gICAgLypcbiAgICAgKiBUcmVhdCBwYWNrZWQga2V5cyBhcyBhIHZpcnR1YWwgc29ydGVkIGFycmF5IG9mIGxlbmd0aCBgYnJhbmNoQ291bnRgLlxuICAgICAqIEtleShpKSA9IGxvdyBieXRlIGZvciBldmVuIGksIGhpZ2ggYnl0ZSBmb3Igb2RkIGkgaW4gc2xvdCBpPj4xLlxuICAgICAqL1xuICAgIGxldCBsbyA9IDA7XG4gICAgbGV0IGhpID0gYnJhbmNoQ291bnQgLSAxO1xuICAgIHdoaWxlIChsbyA8PSBoaSkge1xuICAgICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICAgIGNvbnN0IHNsb3QgPSBtaWQgPj4gMTtcbiAgICAgICAgY29uc3QgcGFja2VkID0gZGVjb2RlVHJlZVtub2RlSW5kZXggKyBzbG90XTtcbiAgICAgICAgY29uc3QgbWlkS2V5ID0gKHBhY2tlZCA+PiAoKG1pZCAmIDEpICogOCkpICYgMHhmZjtcbiAgICAgICAgaWYgKG1pZEtleSA8IGNoYXIpIHtcbiAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaWRLZXkgPiBjaGFyKSB7XG4gICAgICAgICAgICBoaSA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVHJlZVtub2RlSW5kZXggKyBwYWNrZWRLZXlTbG90cyArIG1pZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuY29uc3QgaHRtbERlY29kZXIgPSAvKiAjX19QVVJFX18gKi8gZ2V0RGVjb2RlcihodG1sRGVjb2RlVHJlZSk7XG5jb25zdCB4bWxEZWNvZGVyID0gLyogI19fUFVSRV9fICovIGdldERlY29kZXIoeG1sRGVjb2RlVHJlZSk7XG4vKipcbiAqIERlY29kZXMgYW4gSFRNTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGh0bWxTdHJpbmcgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbW9kZSBUaGUgZGVjb2RpbmcgbW9kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUhUTUwoaHRtbFN0cmluZywgbW9kZSA9IERlY29kaW5nTW9kZS5MZWdhY3kpIHtcbiAgICByZXR1cm4gaHRtbERlY29kZXIoaHRtbFN0cmluZywgbW9kZSk7XG59XG4vKipcbiAqIERlY29kZXMgYW4gSFRNTCBzdHJpbmcgaW4gYW4gYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSBodG1sQXR0cmlidXRlIFRoZSBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSFRNTEF0dHJpYnV0ZShodG1sQXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIGh0bWxEZWNvZGVyKGh0bWxBdHRyaWJ1dGUsIERlY29kaW5nTW9kZS5BdHRyaWJ1dGUpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGFuIEhUTUwgc3RyaW5nLCByZXF1aXJpbmcgYWxsIGVudGl0aWVzIHRvIGJlIHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24uXG4gKlxuICogQHBhcmFtIGh0bWxTdHJpbmcgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVIVE1MU3RyaWN0KGh0bWxTdHJpbmcpIHtcbiAgICByZXR1cm4gaHRtbERlY29kZXIoaHRtbFN0cmluZywgRGVjb2RpbmdNb2RlLlN0cmljdCk7XG59XG4vKipcbiAqIERlY29kZXMgYW4gWE1MIHN0cmluZywgcmVxdWlyaW5nIGFsbCBlbnRpdGllcyB0byBiZSB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICpcbiAqIEBwYXJhbSB4bWxTdHJpbmcgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVYTUwoeG1sU3RyaW5nKSB7XG4gICAgcmV0dXJuIHhtbERlY29kZXIoeG1sU3RyaW5nLCBEZWNvZGluZ01vZGUuU3RyaWN0KTtcbn1cbmV4cG9ydCB7IGRlY29kZUNvZGVQb2ludCwgZnJvbUNvZGVQb2ludCwgcmVwbGFjZUNvZGVQb2ludCwgfSBmcm9tIFwiLi9kZWNvZGUtY29kZXBvaW50LmpzXCI7XG4vLyBSZS1leHBvcnQgZm9yIHVzZSBieSBlZy4gaHRtbHBhcnNlcjJcbmV4cG9ydCB7IGh0bWxEZWNvZGVUcmVlIH0gZnJvbSBcIi4vZ2VuZXJhdGVkL2RlY29kZS1kYXRhLWh0bWwuanNcIjtcbmV4cG9ydCB7IHhtbERlY29kZVRyZWUgfSBmcm9tIFwiLi9nZW5lcmF0ZWQvZGVjb2RlLWRhdGEteG1sLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/decode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-html.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-html.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   htmlDecodeTree: () => (/* binding */ htmlDecodeTree)\n/* harmony export */ });\n/* harmony import */ var _internal_decode_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/decode-shared.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/decode-shared.js\");\n// Generated using scripts/write-decode-map.ts\n\nconst htmlDecodeTree = /* #__PURE__ */ (0,_internal_decode_shared_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase64)(\"QR08ALkAAgH6AYsDNQR2BO0EPgXZBQEGLAbdBxMISQrvCmQLfQurDKQNLw4fD4YPpA+6D/IPAAAAAAAAAAAAAAAAKhBMEY8TmxUWF2EYLBkxGuAa3RsJHDscWR8YIC8jSCSIJcMl6ie3Ku8rEC0CLjoupS7kLgAIRU1hYmNmZ2xtbm9wcnN0dVQAWgBeAGUAaQBzAHcAfgCBAIQAhwCSAJoAoACsALMAbABpAGcAO4DGAMZAUAA7gCYAJkBjAHUAdABlADuAwQDBQHIiZXZlAAJhAAFpeW0AcgByAGMAO4DCAMJAEGRyAADgNdgE3XIAYQB2AGUAO4DAAMBA8CFoYZFj4SFjcgBhZAAAoFMqAAFncIsAjgBvAG4ABGFmAADgNdg43fAlbHlGdW5jdGlvbgCgYSBpAG4AZwA7gMUAxUAAAWNzpACoAHIAAOA12Jzc6SFnbgCgVCJpAGwAZABlADuAwwDDQG0AbAA7gMQAxEAABGFjZWZvcnN1xQDYANoA7QDxAPYA+QD8AAABY3LJAM8AayNzbGFzaAAAoBYidgHTANUAAKDnKmUAZAAAoAYjeQARZIABY3J0AOAA5QDrAGEidXNlAACgNSLuI291bGxpcwCgLCFhAJJjcgAA4DXYBd1wAGYAAOA12Dnd5SF2ZdhiYwDyAOoAbSJwZXEAAKBOIgAHSE9hY2RlZmhpbG9yc3UXARoBHwE6AVIBVQFiAWQBZgGCAakB6QHtAfIBYwB5ACdkUABZADuAqQCpQIABY3B5ACUBKAE1AfUhdGUGYWmg0iJ0KGFsRGlmZmVyZW50aWFsRAAAoEUhbCJleXMAAKAtIQACYWVpb0EBRAFKAU0B8iFvbgxhZABpAGwAO4DHAMdAcgBjAAhhbiJpbnQAAKAwIm8AdAAKYQABZG5ZAV0BaSJsbGEAuGB0I2VyRG90ALdg8gA5AWkAp2NyImNsZQAAAkRNUFRwAXQBeQF9AW8AdAAAoJkiaSJudXMAAKCWIuwhdXMAoJUiaSJtZXMAAKCXIm8AAAFjc4cBlAFrKndpc2VDb250b3VySW50ZWdyYWwAAKAyImUjQ3VybHkAAAFEUZwBpAFvJXVibGVRdW90ZQAAoB0gdSJvdGUAAKAZIAACbG5wdbABtgHNAdgBbwBuAGWgNyIAoHQqgAFnaXQAvAHBAcUB8iJ1ZW50AKBhIm4AdAAAoC8i7yV1ckludGVncmFsAKAuIgABZnLRAdMBAKACIe8iZHVjdACgECJuLnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbAAAoDMi7yFzcwCgLypjAHIAAOA12J7ccABDoNMiYQBwAACgTSKABURKU1phY2VmaW9zAAsCEgIVAhgCGwIsAjQCOQI9AnMCfwNvoEUh9CJyYWhkAKARKWMAeQACZGMAeQAFZGMAeQAPZIABZ3JzACECJQIoAuchZXIAoCEgcgAAoKEhaAB2AACg5CoAAWF5MAIzAvIhb24OYRRkbAB0oAciYQCUY3IAAOA12AfdAAFhZkECawIAAWNtRQJnAvIjaXRpY2FsAAJBREdUUAJUAl8CYwJjInV0ZQC0YG8AdAFZAloC2WJiJGxlQWN1dGUA3WJyImF2ZQBgYGkibGRlANxi7yFuZACgxCJmJWVyZW50aWFsRAAAoEYhcAR9AgAAAAAAAIECjgIAABoDZgAA4DXYO91EoagAhQKJAm8AdAAAoNwgcSJ1YWwAAKBQIuIhbGUAA0NETFJVVpkCqAK1Au8C/wIRA28AbgB0AG8AdQByAEkAbgB0AGUAZwByAGEA7ADEAW8AdAKvAgAAAACwAqhgbiNBcnJvdwAAoNMhAAFlb7kC0AJmAHQAgAFBUlQAwQLGAs0CciJyb3cAAKDQIekkZ2h0QXJyb3cAoNQhZQDlACsCbgBnAAABTFLWAugC5SFmdAABQVLcAuECciJyb3cAAKD4J+kkZ2h0QXJyb3cAoPon6SRnaHRBcnJvdwCg+SdpImdodAAAAUFU9gL7AnIicm93AACg0iFlAGUAAKCoInAAQQIGAwAAAAALA3Iicm93AACg0SFvJHduQXJyb3cAAKDVIWUlcnRpY2FsQmFyAACgJSJuAAADQUJMUlRhJAM2AzoDWgNxA3oDciJyb3cAAKGTIUJVLAMwA2EAcgAAoBMpcCNBcnJvdwAAoPUhciJldmUAEWPlIWZ00gJDAwAASwMAAFIDaSVnaHRWZWN0b3IAAKBQKWUkZVZlY3RvcgAAoF4p5SJjdG9yQqC9IWEAcgAAoFYpaSJnaHQA1AFiAwAAaQNlJGVWZWN0b3IAAKBfKeUiY3RvckKgwSFhAHIAAKBXKWUAZQBBoKQiciJyb3cAAKCnIXIAcgBvAPcAtAIAAWN0gwOHA3IA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YwAAoN8i4SFycnCgtiEAoD0pgKIqImJjZG9zACsVMBU6FT4VQRVyImNhcAAAoEgqAAFhdTQVNxVwAACgRipwAACgSipvAHQAAKCNInIAAKBFKgDgKiIA/gACYWxydksVURVuFXMVcgByAG2gtyEAoDwpeQCAAWV2dwBYFWUVaRVxAHACXxUAAAAAYxVyAGUA4wAXFXUA4wAZFWUAZQAAoM4iZSJkZ2UAAKDPImUAbgA7gKQApEBlI2Fycm93AAABbHJ7FX8V5SFmdACgtiFpImdodAAAoLchZQDkAG0VAAFjaYsVkRVvAG4AaQBuAPQAkwFuAHQAAKAxImwiY3R5AACgLSOACUFIYWJjZGVmaGlqbG9yc3R1d3oAuBW7Fb8V1RXgFegV+RUKFhUWHxZUFlcWZRbFFtsW7xb7FgUXChdyAPIAtAJhAHIAAKBlKQACZ2xyc8YVyhXOFdAV5yFlcgCgICDlIXRoAKA4IfIA9QxoAHagECAAoKMiawHZFd4VYSJyb3cAAKAPKWEA4wBfAgABYXnkFecV8iFvbg9hNGQAoUYhYW/tFfQVAAFnciEC8RVyAACgyiF0InNlcQAAoHcqgAFnbG0A/xUCFgUWO4CwALBAdABhALRjcCJ0eXYAAKCxKQABaXIOFhIW8yFodACgfykA4DXYId1hAHIAAAFschsWHRYAoMMhAKDCIYACYWVnc3YAKBauAjYWOhY+Fm0AAKHEIm9zLhY0Fm4AZABzoMQi9SFpdACgZiZhIm1tYQDdY2kAbgAAoPIiAKH3AGlvQxZRFmQAZQAAgfcAO29KFksW90BuI3RpbWVzAACgxyJuAPgAUBZjAHkAUmRjAG8CXhYAAAAAYhZyAG4AAKAeI28AcAAAoA0jgAJscHR1dwBuFnEWdRaSFp4W7CFhciRgZgAA4DXYVd0AotkCZW1wc30WhBaJFo0WcQBkoFAibwB0AACgUSJpIm51cwAAoDgi7CF1cwCgFCLxInVhcmUAoKEiYgBsAGUAYgBhAHIAdwBlAGQAZwDlANcAbgCAAWFkaAClFqoWtBZyAHIAbwD3APUMbwB3AG4AYQByAHIAbwB3APMA8xVhI3Jwb29uAAABbHK8FsAWZQBmAPQAHBZpAGcAaAD0AB4WYgHJFs8WawBhAHIAbwD3AJILbwLUFgAAAADYFnIAbgAAoB8jbwBwAACgDCOAAWNvdADhFukW7BYAAXJ55RboFgDgNdi53FVkbAAAoPYp8iFvaxFhAAFkcvMW9xZvAHQAAKDxImkA5qC/JVsSAAFhaP8WAhdyAPIANQNhAPIA1wvhIm5nbGUAoKYpAAFjaQ4XEBd5AF9k5yJyYXJyAKD/JwAJRGFjZGVmZ2xtbm9wcXJzdHV4MRc4F0YXWxcyBF4XaRd5F40XrBe0F78X2RcVGCEYLRg1GEAYAAFEbzUXgRZvAPQA+BUAAWNzPBdCF3UAdABlADuA6QDpQPQhZXIAoG4qAAJhaW95TRdQF1YXWhfyIW9uG2FyAGOgViI7gOoA6kDsIW9uAKBVIk1kbwB0ABdhAAFEcmIXZhdvAHQAAKBSIgDgNdgi3XKhmipuF3QXYQB2AGUAO4DoAOhAZKCWKm8AdAAAoJgqgKGZKmlscwCAF4UXhxfuInRlcnMAoOcjAKATIWSglSpvAHQAAKCXKoABYXBzAJMXlheiF2MAcgATYXQAeQBzogUinxcAAAAAoRdlAHQAAKAFInAAMaADIDMBqRerFwCgBCAAoAUgAAFnc7AXsRdLYXAAAKACIAABZ3C4F7sXbwBuABlhZgAA4DXYVt2AAWFscwDFF8sXzxdyAHOg1SJsAACg4yl1AHMAAKBxKmkAAKG1A2x21RfYF28AbgC1Y/VjAAJjc3V24BfoF/0XEBgAAWlv5BdWF3IAYwAAoFYiaQLuFwAAAADwF+0ADQThIW50AAFnbPUX+Rd0AHIAAKCWKuUhc3MAoJUqgAFhZWkAAxgGGAoYbABzAD1gcwB0AACgXyJ2AESgYSJEAACgeCrwImFyc2wAoOUpAAFEYRkYHRhvAHQAAKBTInIAcgAAoHEpgAFjZGkAJxgqGO0XcgAAoC8hbwD0AIwCAAFhaDEYMhi3YzuA8ADwQAABbXI5GD0YbAA7gOsA60BvAACgrCCAAWNpcABGGEgYSxhsACFgcwD0ACwEAAFlb08YVxhjAHQAYQB0AGkAbwDuABoEbgBlAG4AdABpAGEAbADlADME4Ql1GAAAgRgAAIMYiBgAAAAAoRilGAAAqhgAALsYvhjRGAAA1xgnGWwAbABpAG4AZwBkAG8AdABzAGUA8QBlF3kARGRtImFsZQAAoEAmgAFpbHIAjRiRGJ0Y7CFpZwCgA/tpApcYAAAAAJoYZwAAoAD7aQBnAACgBPsA4DXYI93sIWlnAKAB++whaWcA4GYAagCAAWFsdACvGLIYthh0AACgbSZpAGcAAKAC+24AcwAAoLElbwBmAJJh8AHCGAAAxhhmAADgNdhX3QABYWvJGMwYbADsAGsEdqDUIgCg2SphI3J0aW50AACgDSoAAWFv2hgiGQABY3PeGB8ZsQPnGP0YBRkSGRUZAAAdGbID7xjyGPQY9xj5GAAA+xg7gL0AvUAAoFMhO4C8ALxAAKBVIQCgWSEAoFshswEBGQAAAxkAoFQhAKBWIbQCCxkOGQAAAAAQGTuAvgC+QACgVyEAoFwhNQAAoFghtgEZGQAAGxkAoFohAKBdITgAAKBeIWwAAKBEIHcAbgAAoCIjYwByAADgNdi73IAIRWFiY2RlZmdpamxub3JzdHYARhlKGVoZXhlmGWkZkhmWGZkZnRmgGa0ZxhnLGc8Z4BkjGmygZyIAoIwqgAFjbXAAUBlTGVgZ9SF0ZfVhbQBhAOSgswM6FgCghipyImV2ZQAfYQABaXliGWUZcgBjAB1hM2RvAHQAIWGAoWUibHFzAMYEcBl6GfGhZSLOBAAAdhlsAGEAbgD0AN8EgKF+KmNkbACBGYQZjBljAACgqSpvAHQAb6CAKmyggioAoIQqZeDbIgD+cwAAoJQqcgAA4DXYJN3noGsirATtIWVsAKA3IWMAeQBTZIChdyJFYWoApxmpGasZAKCSKgCgpSoAoKQqAAJFYWVztBm2Gb0ZwhkAoGkicABwoIoq8iFveACgiipxoIgq8aCIKrUZaQBtAACg5yJwAGYAAOA12FjdYQB2AOUAYwIAAWNp0xnWGXIAAKAKIW0AAKFzImVs3BneGQCgjioAoJAqAIM+ADtjZGxxco0E6xn0GfgZ/BkBGgABY2nvGfEZAKCnKnIAAKB6Km8AdAAAoNci0CFhcgCglSl1ImVzdAAAoHwqgAJhZGVscwAKGvQZFhrVBCAa8AEPGgAAFBpwAHIAbwD4AFkZcgAAoHgpcQAAAWxxxAQbGmwAZQBzAPMASRlpAO0A5AQAAWVuJxouGnIjdG5lcXEAAOBpIgD+xQAsGgAFQWFiY2Vma29zeUAaQxpmGmoabRqDGocalhrCGtMacgDyAMwCAAJpbG1yShpOGlAaVBpyAHMA8ABxD2YAvWBpAGwA9AASBQABZHJYGlsaYwB5AEpkAKGUIWN3YBpkGmkAcgAAoEgpAKCtIWEAcgAAoA8h6SFyYyVhgAFhbHIAcxp7Gn8a8iF0c3WgZSZpAHQAAKBlJuwhaXAAoCYg4yFvbgCguSJyAADgNdgl3XMAAAFld4wakRphInJvdwAAoCUpYSJyb3cAAKAmKYACYW1vcHIAnxqjGqcauhq+GnIAcgAAoP8h9CFodACgOyJrAAABbHKsGrMaZSRmdGFycm93AACgqSHpJGdodGFycm93AKCqIWYAAOA12Fnd4iFhcgCgFSCAAWNsdADIGswa0BpyAADgNdi93GEAcwDoAGka8iFvaydhAAFicNca2xr1IWxsAKBDIOghZW4AoBAg4Qr2GgAA/RoAAAgbExsaGwAAIRs7GwAAAAA+G2IbmRuVG6sbAACyG80b0htjAHUAdABlADuA7QDtQAChYyBpeQEbBhtyAGMAO4DuAO5AOGQAAWN4CxsNG3kANWRjAGwAO4ChAKFAAAFmcssCFhsA4DXYJt1yAGEAdgBlADuA7ADsQIChSCFpbm8AJxsyGzYbAAFpbisbLxtuAHQAAKAMKnQAAKAtIuYhaW4AoNwpdABhAACgKSHsIWlnM2GAAWFvcABDG1sbXhuAAWNndABJG0sbWRtyACthgAFlbHAAcQVRG1UbaQBuAOUAyAVhAHIA9AByBWgAMWFmAACgtyJlAGQAtWEAoggiY2ZvdGkbbRt1G3kb4SFyZQCgBSFpAG4AdKAeImkAZQAAoN0pZABvAPQAWxsAoisiY2VscIEbhRuPG5QbYQBsAACguiIAAWdyiRuNG2UAcgDzACMQ4wCCG2EicmhrAACgFyryIW9kAKA8KgACY2dwdJ8boRukG6gbeQBRZG8AbgAvYWYAAOA12FrdYQC5Y3UAZQBzAHQAO4C/AL9AAAFjabUbuRtyAADgNdi+3G4AAKIIIkVkc3bCG8QbyBvQAwCg+SJvAHQAAKD1Inag9CIAoPMiaaBiIOwhZGUpYesB1hsAANkbYwB5AFZkbAA7gO8A70AAA2NmbW9zdeYb7hvyG/Ub+hsFHAABaXnqG+0bcgBjADVhOWRyAADgNdgn3eEhdGg3YnAAZgAA4DXYW93jAf8bAAADHHIAAOA12L/c8iFjeVhk6yFjeVRkAARhY2ZnaGpvcxUcGhwiHCYcKhwtHDAcNRzwIXBhdqC6A/BjAAFleR4cIRzkIWls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ZmdobG1vcHJzdHV3CiwNLBEsHSwnLDEsQCxLLFIsYix6LIQsjyzLLOgs7Sz/LAotcgDyAAkDYQByAACgYykAAWNyFSwbLHUAdABlADuA+gD6QPIACQ1yAOMBIywAACUseQBeZHYAZQBtYQABaXkrLDAscgBjADuA+wD7QENkgAFhYmgANyw6LD0scgDyANEO7CFhY3FhYQDyAOAOAAFpckQsSCzzIWh0AKB+KQDgNdgy3XIAYQB2AGUAO4D5APlAYQFWLF8scgAAAWxyWixcLACgvyEAoL4hbABrAACggCUAAWN0Zix2LG8CbCwAAAAAcyxyAG4AZaAcI3IAAKAcI28AcAAAoA8jcgBpAACg+CUAAWFsfiyBLGMAcgBrYTuAqACoQAABZ3CILIssbwBuAHNhZgAA4DXYZt0AA2FkaGxzdZksniynLLgsuyzFLHIAcgBvAPcACQ1vAHcAbgBhAHIAcgBvAPcA2A5hI3Jwb29uAAABbHKvLLMsZQBmAPQAWyxpAGcAaAD0AF0sdQDzAKYOaQAAocUDaGzBLMIs0mNvAG4AxWPwI2Fycm93cwCgyCGAAWNpdADRLOEs5CxvAtcsAAAAAN4scgBuAGWgHSNyAACgHSNvAHAAAKAOI24AZwBvYXIAaQAAoPklYwByAADgNdjK3IABZGlyAPMs9yz6LG8AdAAAoPAi7CFkZWlhaQBmoLUlAKC0JQABYW0DLQYtcgDyAMosbAA7gPwA/EDhIm5nbGUAoKcpgAdBQkRhY2RlZmxub3Byc3oAJy0qLTAtNC2bLZ0toS2/LcMtxy3TLdgt3C3gLfwtcgDyABADYQByAHag6CoAoOkqYQBzAOgA/gIAAW5yOC08LechcnQAoJwpgANla25wcnN0AJkpSC1NLVQtXi1iLYItYQBwAHAA4QAaHG8AdABoAGkAbgDnAKEXgAFoaXIAoSmzJFotbwBwAPQAdCVooJUh7wD4JgABaXVmLWotZwBtAOEAuygAAWJwbi14LXMjZXRuZXEAceCKIgD+AODLKgD+cyNldG5lcQBx4IsiAP4A4MwqAP4AAWhyhi2KLWUAdADhABIraSNhbmdsZQAAAWxyki2WLeUhZnQAoLIiaSJnaHQAAKCzInkAMmThIXNoAKCiIoABZWxyAKcttC24LWKiKCKuLQAAAACyLWEAcgAAoLsicQAAoFoi7CFpcACg7iIAAWJ0vC1eD2EA8gBfD3IAAOA12DPddAByAOkAlS1zAHUAAAFicM0t0C0A4IIi0iAA4IMi0iBwAGYAAOA12GfdcgBvAPAAWQt0AHIA6QCaLQABY3XkLegtcgAA4DXYy9wAAWJw7C30LW4AAAFFZXUt8S0A4IoiAP5uAAABRWV/LfktAOCLIgD+6SJnemFnAKCaKYADY2Vmb3BycwANLhAuJS4pLiMuLi40LukhcmN1YQABZGkULiEuAAFiZxguHC5hAHIAAKBfKmUAcaAnIgCgWSLlIXJwAKAYIXIAAOA12DTdcABmAADgNdho3WWgQCJhAHQA6ABqD2MAcgAA4DXYzNzjCuQRUC4AAFQuAABYLmIuAAAAAGMubS5wLnQuAAAAAIguki4AAJouJxIqEnQAcgDpAB0ScgAA4DXYNd0AAUFhWy5eLnIA8gDnAnIA8gCTB75jAAFBYWYuaS5yAPIA4AJyAPIAjAdhAPAAeh5pAHMAAKD7IoABZHB0APgReS6DLgABZmx9LoAuAOA12GnddQDzAP8RaQBtAOUABBIAAUFhiy6OLnIA8gDuAnIA8gCaBwABY3GVLgoScgAA4DXYzdwAAXB0nS6hLmwAdQDzACUScgDpACASAARhY2VmaW9zdbEuvC7ELsguzC7PLtQu2S5jAAABdXm2LrsudABlADuA/QD9QE9kAAFpecAuwy5yAGMAd2FLZG4AO4ClAKVAcgAA4DXYNt1jAHkAV2RwAGYAAOA12GrdYwByAADgNdjO3AABY23dLt8ueQBOZGwAO4D/AP9AAAVhY2RlZmhpb3N38y73Lv8uAi8MLxAvEy8YLx0vIi9jInV0ZQB6YQABYXn7Lv4u8iFvbn5hN2RvAHQAfGEAAWV0Bi8KL3QAcgDmAB8QYQC2Y3IAAOA12DfdYwB5ADZk5yJyYXJyAKDdIXAAZgAA4DXYa91jAHIAAOA12M/cAAFqbiYvKC8AoA0gagAAoAwg\");\n//# sourceMappingURL=decode-data-html.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDNEQ7QUFDckQsdUNBQXVDLHdFQUFZO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJjYWRlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzPzE4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIHVzaW5nIHNjcmlwdHMvd3JpdGUtZGVjb2RlLW1hcC50c1xuaW1wb3J0IHsgZGVjb2RlQmFzZTY0IH0gZnJvbSBcIi4uL2ludGVybmFsL2RlY29kZS1zaGFyZWQuanNcIjtcbmV4cG9ydCBjb25zdCBodG1sRGVjb2RlVHJlZSA9IC8qICNfX1BVUkVfXyAqLyBkZWNvZGVCYXNlNjQoXCJRUjA4QUxrQUFnSDZBWXNETlFSMkJPMEVQZ1haQlFFR0xBYmRCeE1JU1FydkNtUUxmUXVyREtRTkx3NGZENFlQcEErNkQvSVBBQUFBQUFBQUFBQUFBQUFBS2hCTUVZOFRteFVXRjJFWUxCa3hHdUFhM1JzSkhEc2NXUjhZSUM4alNDU0lKY01sNmllM0t1OHJFQzBDTGpvdXBTN2tMZ0FJUlUxaFltTm1aMnh0Ym05d2NuTjBkVlFBV2dCZUFHVUFhUUJ6QUhjQWZnQ0JBSVFBaHdDU0FKb0FvQUNzQUxNQWJBQnBBR2NBTzRER0FNWkFVQUE3Z0NZQUprQmpBSFVBZEFCbEFEdUF3UURCUUhJaVpYWmxBQUpoQUFGcGVXMEFjZ0J5QUdNQU80RENBTUpBRUdSeUFBRGdOZGdFM1hJQVlRQjJBR1VBTzREQUFNQkE4Q0ZvWVpGajRTRmpjZ0JoWkFBQW9GTXFBQUZuY0lzQWpnQnZBRzRBQkdGbUFBRGdOZGc0M2ZBbGJIbEdkVzVqZEdsdmJnQ2dZU0JwQUc0QVp3QTdnTVVBeFVBQUFXTnpwQUNvQUhJQUFPQTEySnpjNlNGbmJnQ2dWQ0pwQUd3QVpBQmxBRHVBd3dERFFHMEFiQUE3Z01RQXhFQUFCR0ZqWldadmNuTjF4UURZQU5vQTdRRHhBUFlBK1FEOEFBQUJZM0xKQU04QWF5TnpiR0Z6YUFBQW9CWWlkZ0hUQU5VQUFLRG5LbVVBWkFBQW9BWWplUUFSWklBQlkzSjBBT0FBNVFEckFHRWlkWE5sQUFDZ05TTHVJMjkxYkd4cGN3Q2dMQ0ZoQUpKamNnQUE0RFhZQmQxd0FHWUFBT0ExMkRuZDVTRjJaZGhpWXdEeUFPb0FiU0p3WlhFQUFLQk9JZ0FIU0U5aFkyUmxabWhwYkc5eWMzVVhBUm9CSHdFNkFWSUJWUUZpQVdRQlpnR0NBYWtCNlFIdEFmSUJZd0I1QUNka1VBQlpBRHVBcVFDcFFJQUJZM0I1QUNVQktBRTFBZlVoZEdVR1lXbWcwaUowS0dGc1JHbG1abVZ5Wlc1MGFXRnNSQUFBb0VVaGJDSmxlWE1BQUtBdElRQUNZV1ZwYjBFQlJBRktBVTBCOGlGdmJneGhaQUJwQUd3QU80REhBTWRBY2dCakFBaGhiaUpwYm5RQUFLQXdJbThBZEFBS1lRQUJaRzVaQVYwQmFTSnNiR0VBdUdCMEkyVnlSRzkwQUxkZzhnQTVBV2tBcDJOeUltTnNaUUFBQWtSTlVGUndBWFFCZVFGOUFXOEFkQUFBb0praWFTSnVkWE1BQUtDV0l1d2hkWE1Bb0pVaWFTSnRaWE1BQUtDWEltOEFBQUZqYzRjQmxBRnJLbmRwYzJWRGIyNTBiM1Z5U1c1MFpXZHlZV3dBQUtBeUltVWpRM1Z5YkhrQUFBRkVVWndCcEFGdkpYVmliR1ZSZFc5MFpRQUFvQjBnZFNKdmRHVUFBS0FaSUFBQ2JHNXdkYkFCdGdITkFkZ0Jid0J1QUdXZ055SUFvSFFxZ0FGbmFYUUF2QUhCQWNVQjhpSjFaVzUwQUtCaEltNEFkQUFBb0M4aTd5VjFja2x1ZEdWbmNtRnNBS0F1SWdBQlpuTFJBZE1CQUtBQ0llOGlaSFZqZEFDZ0VDSnVMblJsY2tOc2IyTnJkMmx6WlVOdmJuUnZkWEpKYm5SbFozSmhiQUFBb0RNaTd5Rnpjd0NnTHlwakFISUFBT0ExMko3Y2NBQkRvTk1pWVFCd0FBQ2dUU0tBQlVSS1UxcGhZMlZtYVc5ekFBc0NFZ0lWQWhnQ0d3SXNBalFDT1FJOUFuTUNmd052b0VVaDlDSnlZV2hrQUtBUktXTUFlUUFDWkdNQWVRQUZaR01BZVFBUFpJQUJaM0p6QUNFQ0pRSW9BdWNoWlhJQW9DRWdjZ0FBb0tFaGFBQjJBQUNnNUNvQUFXRjVNQUl6QXZJaGIyNE9ZUlJrYkFCMG9BY2lZUUNVWTNJQUFPQTEyQWZkQUFGaFprRUNhd0lBQVdOdFJRSm5BdklqYVhScFkyRnNBQUpCUkVkVVVBSlVBbDhDWXdKakluVjBaUUMwWUc4QWRBRlpBbG9DMldKaUpHeGxRV04xZEdVQTNXSnlJbUYyWlFCZ1lHa2liR1JsQU54aTd5RnVaQUNneENKbUpXVnlaVzUwYVdGc1JBQUFvRVloY0FSOUFnQUFBQUFBQUlFQ2pnSUFBQm9EWmdBQTREWFlPOTFFb2FnQWhRS0pBbThBZEFBQW9Od2djU0oxWVd3QUFLQlFJdUloYkdVQUEwTkVURkpWVnBrQ3FBSzFBdThDL3dJUkEyOEFiZ0IwQUc4QWRRQnlBRWtBYmdCMEFHVUFad0J5QUdFQTdBREVBVzhBZEFLdkFnQUFBQUN3QXFoZ2JpTkJjbkp2ZHdBQW9OTWhBQUZsYjdrQzBBSm1BSFFBZ0FGQlVsUUF3UUxHQXMwQ2NpSnliM2NBQUtEUUlla2taMmgwUVhKeWIzY0FvTlFoWlFEbEFDc0NiZ0JuQUFBQlRGTFdBdWdDNVNGbWRBQUJRVkxjQXVFQ2NpSnliM2NBQUtENEora2taMmgwUVhKeWIzY0FvUG9uNlNSbmFIUkJjbkp2ZHdDZytTZHBJbWRvZEFBQUFVRlU5Z0w3QW5JaWNtOTNBQUNnMGlGbEFHVUFBS0NvSW5BQVFRSUdBd0FBQUFBTEEzSWljbTkzQUFDZzBTRnZKSGR1UVhKeWIzY0FBS0RWSVdVbGNuUnBZMkZzUW1GeUFBQ2dKU0p1QUFBRFFVSk1VbFJoSkFNMkF6b0RXZ054QTNvRGNpSnliM2NBQUtHVElVSlZMQU13QTJFQWNnQUFvQk1wY0NOQmNuSnZkd0FBb1BVaGNpSmxkbVVBRVdQbElXWjAwZ0pEQXdBQVN3TUFBRklEYVNWbmFIUldaV04wYjNJQUFLQlFLV1VrWlZabFkzUnZjZ0FBb0Y0cDVTSmpkRzl5UXFDOUlXRUFjZ0FBb0ZZcGFTSm5hSFFBMUFGaUF3QUFhUU5sSkdWV1pXTjBiM0lBQUtCZktlVWlZM1J2Y2tLZ3dTRmhBSElBQUtCWEtXVUFaUUJCb0tRaWNpSnliM2NBQUtDbklYSUFjZ0J2QVBjQXRBSUFBV04wZ3dPSEEzSUFBT0ExMkovYzhpRnZheEJoQUFoT1ZHRmpaR1puYkcxdmNIRnpkSFY0b3dPbEE2a0RzQU8vQThJRHhnUE5BOUlEOGdQOUF3RUVGQVFlQkNBRUpRUkhBRXBoU0FBN2dOQUEwRUJqQUhVQWRBQmxBRHVBeVFESlFJQUJZV2w1QUxZRHVRTytBL0loYjI0YVlYSUFZd0E3Z01vQXlrQXRaRzhBZEFBV1lYSUFBT0ExMkFqZGNnQmhBSFlBWlFBN2dNZ0F5RURsSW0xbGJuUUFvQWdpQUFGaGNOWUQyUU5qQUhJQUVtRjBBSGtBVXdMaEF3QUFBQURwQTIwbFlXeHNVM0YxWVhKbEFBQ2creVZsSjNKNVUyMWhiR3hUY1hWaGNtVUFBS0NySlFBQlozRDJBL2tEYndCdUFCaGhaZ0FBNERYWVBOM3pJbWxzYjI2VlkzVUFBQUZoYVFZRURnUnNBRlNnZFNwcElteGtaUUFBb0VJaTdDTnBZbkpwZFcwQW9Nd2hBQUZqYVJnRUd3UnlBQUNnTUNGdEFBQ2djeXBoQUpkamJRQnNBRHVBeXdETFFBQUJhWEFwQkMwRTh5RjBjd0NnQXlMdkpHNWxiblJwWVd4RkFLQkhJWUFDWTJacGIzTUFQUVEvQkVNRVhRUnlCSGtBSkdSeUFBRGdOZGdKM1d3aWJHVmtBRk1DVEFRQUFBQUFWQVJ0SldGc2JGTnhkV0Z5WlFBQW9Qd2xaU2R5ZVZOdFlXeHNVM0YxWVhKbEFBQ2dxaVZ3QTJVRUFBQnBCQUFBQUFCdEJHWUFBT0ExMkQzZHdTRnNiQUNnQUNMeUkybGxjblJ5WmdDZ01TRmpBUElBY1FRQUJrcFVZV0pqWkdabmIzSnpkSWdFaXdTT0JKTUVsd1NrQktjRXF3U3RCTElFNVFUcUJHTUFlUUFEWkR1QVBnQStRTzBoYldGa29KTUQzR055SW1WMlpRQWVZWUFCWldsNUFKMEVvQVNqQk9RaGFXd2lZWElBWXdBY1lSTmtid0IwQUNCaGNnQUE0RFhZQ3QwQW9Oa2ljQUJtQUFEZ05kZyszZVVpWVhSbGNnQURSVVpIVEZOVXZ3VElCTThFMVFUWkJPQUVjU0oxWVd3QVRLQmxJdVVoYzNNQW9Oc2lkU1JzYkVWeGRXRnNBQUNnWnlKeUkyVmhkR1Z5QUFDZ29pcmxJWE56QUtCM0l1d2tZVzUwUlhGMVlXd0FvSDRxYVNKc1pHVUFBS0J6SW1NQWNnQUE0RFhZb3R3QW9Hc2lBQVJCWVdObWFXOXpkZmtFL1FRRkJRZ0ZDd1VUQlNJRkt3VlNJa1JqZVFBcVpBQUJZM1FCQlFRRlpRQnJBTWRpWG1EcElYSmpKR0Z5QUFDZ0RDRnNKV0psY25SVGNHRmpaUUFBb0FzaDhBRVlCUUFBR3dWbUFBQ2dEU0hwSlhwdmJuUmhiRXhwYm1VQW9BQWxBQUZqZENZRktBWHlBQklGOGlGdmF5WmhiUUJ3QUVRQk1RVTVCVzhBZHdCdUFFZ0FkUUJ0QVBBQUFBRnhJblZoYkFBQW9FOGlBQWRGU2s5aFkyUm1aMjF1YjNOMGRWTUZWZ1ZaQlZ3Rll3VnRCWEFGY3dWNkJaQUZ0Z1hGQmNrRnpRVmpBSGtBRldUc0lXbG5NbUZqQUhrQUFXUmpBSFVBZEFCbEFEdUF6UUROUUFBQmFYbG5CV3dGY2dCakFEdUF6Z0RPUUJoa2J3QjBBREJoY2dBQW9CRWhjZ0JoQUhZQVpRQTdnTXdBekVBQW9SRWhZWEIvQllzRkFBRmpaNE1GaFFWeUFDcGhhU051WVhKNVNRQUFvRWdoYkFCcEFHVUE4d0Q2QXZRQmxRVUFBS1VGWmFBc0lnQUJaM0thQlo0RjhpRmhiQUNnS3lMekkyVmpkR2x2YmdDZ3dpSnBJM05wWW14bEFBQUJRMVNzQmJFRmJ5SnRiV0VBQUtCaklHa2liV1Z6QUFDZ1lpQ0FBV2R3ZEFDOEJiOEZ3d1Z2QUc0QUxtRm1BQURnTmRoQTNXRUFtV05qQUhJQUFLQVFJV2tpYkdSbEFDaGg2d0hTQlFBQTFRVmpBSGtBQm1Sc0FEdUF6d0RQUUlBQ1kyWnZjM1VBNFFYcEJlMEY4Z1g5QlFBQmFYbmxCZWdGY2dCakFEUmhHV1J5QUFEZ05kZ04zWEFBWmdBQTREWFlRZDNqQWZjRkFBRDdCWElBQU9BMTJLWGM4aUZqZVFoazZ5RmplUVJrZ0FOSVNtRmpabTl6QUF3R0R3WVNCaFVHSFFZaEJpWUdZd0I1QUNWa1l3QjVBQXhrOENGd1lacGpBQUZsZVJrR0hBYmtJV2xzTm1FYVpISUFBT0ExMkE3ZGNBQm1BQURnTmRoQzNXTUFjZ0FBNERYWXB0eUFCVXBVWVdObFpteHRiM04wQUQwR1FBWkRCbDRHYXdaa0IyZ0hjQWQwQjgwSDJnZGpBSGtBQ1dRN2dEd0FQRUNBQW1OdGJuQnlBRXdHVHdaU0JsVUdXd2IxSVhSbE9XSGlJV1JobTJObkFBQ2c2aWZzSTJGalpYUnlaZ0NnRWlGeUFBQ2duaUdBQVdGbGVRQmtCbWNHYWdieUlXOXVQV0hrSVdsc08yRWJaQUFCWm5OdkJqUUhkQUFBQlVGRFJFWlNWRlZXWVhLQUJwNEdwQWJHQnNzRzNBWURCeUVId1FJcUJ3QUJibktFQm93R1p5VnNaVUp5WVdOclpYUUFBS0RvSi9JaGIzY0FvWkFoUWxLVEJwY0dZUUJ5QUFDZzVDSHBKR2RvZEVGeWNtOTNBS0RHSVdVamFXeHBibWNBQUtBSUkyOEE5UUdxQmdBQXNnWmlKV3hsUW5KaFkydGxkQUFBb09ZbmJnRFVBYmNHQUFDK0JtVWtaVlpsWTNSdmNnQUFvR0VwNVNKamRHOXlRcURESVdFQWNnQUFvRmtwYkNKdmIzSUFBS0FLSTJraVoyaDBBQUFCUVZiU0J0Y0djaUp5YjNjQUFLQ1VJZVVpWTNSdmNnQ2dUaWtBQVdWeTRBYndCbVVBQUtHaklrRlc1Z2JyQm5JaWNtOTNBQUNncENIbEltTjBiM0lBb0ZvcGFTTmhibWRzWlFCQ29ySWkrd1lBQUFBQS93WmhBSElBQUtEUEtYRWlkV0ZzQUFDZ3RDSndBSUFCUkZSV0FBb0hFUWNZQis4a2QyNVdaV04wYjNJQW9GRXBaU1JsVm1WamRHOXlBQUNnWUNubEltTjBiM0pDb0w4aFlRQnlBQUNnV0NubEltTjBiM0pDb0x3aFlRQnlBQUNnVWlscEFHY0FhQUIwQUdFQWNnQnlBRzhBOXdETUFuTUFBQU5GUmtkTVUxUS9CMGNIVGdkVUIxZ0hYd2Z4SlhWaGJFZHlaV0YwWlhJQW9Ob2lkU1JzYkVWeGRXRnNBQUNnWmlKeUkyVmhkR1Z5QUFDZ2RpTGxJWE56QUtDaEt1d2tZVzUwUlhGMVlXd0FvSDBxYVNKc1pHVUFBS0J5SW5JQUFPQTEyQS9kWmFEWUl1WWpkR0Z5Y205M0FLRGFJV2tpWkc5MEFEOWhnQUZ1Y0hjQWVnZTFCN2tIWndBQUFreFNiSEtDQjVRSG13ZXJCK1VoWm5RQUFVRlNpQWVOQjNJaWNtOTNBQUNnOVNmcEpHZG9kRUZ5Y205M0FLRDNKK2trWjJoMFFYSnliM2NBb1BZbjVTRm1kQUFCWVhMY0FxRUhhUUJuQUdnQWRBQmhBSElBY2dCdkFQY0E1d0pwQUdjQWFBQjBBR0VBY2dCeUFHOEE5d0R1QW1ZQUFPQTEyRVBkWlFCeUFBQUJURksvQjhZSFpTUm1kRUZ5Y205M0FBQ2dtU0hwSkdkb2RFRnljbTkzQUtDWUlZQUJZMmgwQU5NSDFRZlhCL0lBV2dZQW9MQWg4aUZ2YTBGaEFLQnFJZ0FFWVdObFptbHZjM1hwQit3SDdnZi9Cd01JQ1FnT0NCRUljQUFBb0FVcGVRQWNaQUFCWkd6eUIva0hhU1IxYlZOd1lXTmxBQUNnWHlCc0kybHVkSEptQUFDZ015RnlBQURnTmRnUTNlNGpkWE5RYkhWekFLQVRJbkFBWmdBQTREWFlSTjFqQVBJQS9nZWNZNEFFU21GalpXWnZjM1IxQUNFSUpBZ29DRFVJZ1FpRkNEc0tRQXBIQ21NQWVRQUtaR01pZFhSbEFFTmhnQUZoWlhrQUxnZ3hDRFFJOGlGdmJrZGg1Q0ZwYkVWaEhXU0FBV2R6ZHdBN0NHRUlmUWpoSW5ScGRtV0FBVTFVVmdCRUNFd0lXUWhsSldScGRXMVRjR0ZqWlFBQW9Bc2dhQUJwQUFBQlkyNVNDRk1JYXdCVEFIQUFZUUJqQU9VQVN3aGxBSElBZVFCVUFHZ0FhUUR1QUZRSTlDRmxaQUFCUjB4bkNIVUljZ0JsQUdFQWRBQmxBSElBUndCeUFHVUFZUUIwQUdVQThnRHJCR1VBY3dCekFFd0FaUUJ6QVBNQTJ3ZE1JbWx1WlFBS1lISUFBT0ExMkJIZEFBSkNibkIwakFpUkNKa0luQWh5SW1WaGF3QUFvR0Fnd2laeVpXRnJhVzVuVTNCaFkyV2dZR1lBQUtBVklVT3E3Q3F6Q01JSXpRZ0FBT2NJR3drQUFBQUFBQUF0Q1FBQWJ3a0FBSWNKQUFDZENjQUpHUW9BQURRS0FBRnZkYllJdkFqdUkyZHlkV1Z1ZEFDZ1lpSndJa05oY0FBQW9HMGlieWgxWW14bFZtVnlkR2xqWVd4Q1lYSUFBS0FtSW9BQmJIRjRBTklJMXdqaENPVWliV1Z1ZEFDZ0NTTDFJV0ZzVktCZ0lta2liR1JsQUFEZ1FpSTRBMmtpYzNSekFBQ2dCQ0p5STJWaGRHVnlBQUNqYnlKRlJrZE1VMVQxQ1BvSUFna0pDUTBKRlFseEluVmhiQUFBb0hFaWRTUnNiRVZ4ZFdGc0FBRGdaeUk0QTNJalpXRjBaWElBQU9CcklqZ0Q1U0Z6Y3dDZ2VTTHNKR0Z1ZEVWeGRXRnNBT0IrS2pnRGFTSnNaR1VBQUtCMUl2VWhiWEJFQVNBSkp3bnZJM2R1U0hWdGNBRGdUaUk0QTNFaWRXRnNBQURnVHlJNEEyVUFBQUZtY3pFSlJnbjBKRlJ5YVdGdVoyeGxRcUxxSWowSkFBQUFBRUlKWVFCeUFBRGd6eWs0QTNFaWRXRnNBQUNnN0NKekFJQ2liaUpGUjB4VFZBQlJDVllKWEFsaENXa0pjU0oxWVd3QUFLQndJbklqWldGMFpYSUFBS0I0SXVVaGMzTUE0R29pT0FQc0pHRnVkRVZ4ZFdGc0FPQjlLamdEYVNKc1pHVUFBS0IwSXVVaWMzUmxaQUFCUjB4MUNYOEo4aVpsWVhSbGNrZHlaV0YwWlhJQTRLSXFPQVBsSTNOelRHVnpjd0Rnb1NvNEEvSWpaV05sWkdWekFLR0FJa1ZUandtVkNYRWlkV0ZzQUFEZ3J5bzRBK3drWVc1MFJYRjFZV3dBb09BaUFBRmxhYUFKcVFsMkptVnljMlZGYkdWdFpXNTBBQUNnRENMbkpXaDBWSEpwWVc1bmJHVkNvdXNpdGdrQUFBQUF1d2xoQUhJQUFPRFFLVGdEY1NKMVlXd0FBS0R0SWdBQmNYWERDZUFKZFNOaGNtVlRkUUFBQVdKd3l3blZDZk1oWlhSRjRJOGlPQU54SW5WaGJBQUFvT0lpNVNKeWMyVjBSZUNRSWpnRGNTSjFZV3dBQUtEaklvQUJZbU53QU9ZSjhBa05Ddk1oWlhSRjRJSWkwaUJ4SW5WaGJBQUFvSWdpNHlKbFpXUnpnS0dCSWtWVFZBRDZDUUFLQndweEluVmhiQUFBNExBcU9BUHNKR0Z1ZEVWeGRXRnNBS0RoSW1raWJHUmxBQURnZnlJNEErVWljbk5sZEVYZ2d5TFNJSEVpZFdGc0FBQ2dpU0pwSW14a1pRQ0FvVUVpUlVaVUFDSUtKd291Q25FaWRXRnNBQUNnUkNKMUpHeHNSWEYxWVd3QUFLQkhJbWtpYkdSbEFBQ2dTU0psSlhKMGFXTmhiRUpoY2dBQW9DUWlZd0J5QUFEZ05kaXAzR2tBYkFCa0FHVUFPNERSQU5GQW5XTUFCMFZoWTJSbVoyMXZjSEp6ZEhWMlhncGhDbWdLY2dwMkNub0tnUXFSQ3BZS3F3cXRDcnNLeUFyTkN1d2hhV2RTWVdNQWRRQjBBR1VBTzREVEFOTkFBQUZwZVd3S2NRcHlBR01BTzREVUFOUkFIbVJpSW14aFl3QlFZWElBQU9BMTJCTGRjZ0JoQUhZQVpRQTdnTklBMGtDQUFXRmxhUUNIQ29vS2pRcGpBSElBVEdGbkFHRUFxV05qSW5KdmJnQ2ZZM0FBWmdBQTREWFlSdDNsSTI1RGRYSnNlUUFCUkZHZUNxWUtieVYxWW14bFVYVnZkR1VBQUtBY0lIVWliM1JsQUFDZ0dDQUFvRlFxQUFGamJMRUt0UXB5QUFEZ05kaXEzR0VBY3dCb0FEdUEyQURZUUdrQWJBSEFDc1VLWkFCbEFEdUExUURWUUdVQWN3QUFvRGNxYlFCc0FEdUExZ0RXUUdVQWNnQUFBVUpRMHdybUNnQUJZWExYQ3RvS2NnQUFvRDRnWVFCakFBQUJaV3ZnQ3VJS0FLRGVJMlVBZEFBQW9MUWpZU1Z5Wlc1MGFHVnphWE1BQUtEY0k0QUVZV05tYUdsc2IzSnpBUDBLQXdzRkN3a0xDd3NNQ3hFTEl3dGFDM0lqZEdsaGJFUUFBS0FDSW5rQUgyUnlBQURnTmRnVDNXa0FwbU9nWS9VamMwMXBiblZ6c1dBQUFXbHdGUXNnQzI0QVl3QmhBSElBWlFCd0FHd0FZUUJ1QU9VQUNnVm1BQUNnR1NHQW9ic3FaV2x2QUNvTFJRdEpDK01pWldSbGM0Q2hlaUpGVTFRQU5BczVDMEFMY1NKMVlXd0FBS0N2S3V3a1lXNTBSWEYxWVd3QW9Id2lhU0pzWkdVQUFLQitJbTBBWlFBQW9ETWdBQUZrY0UwTFVRdjFJV04wQUtBUEltOGpjblJwYjI0QVlhQTNJbXdBQUtBZElnQUJZMmxlQzJJTGNnQUE0RFhZcTl5b1l3QUNWV1p2YzJvTGJ3dHpDM2NMVHdCVUFEdUFJZ0FpUUhJQUFPQTEyQlRkY0FCbUFBQ2dHaUZqQUhJQUFPQTEyS3pjQUFaQ1JXRmpaV1pvYVc5eWMzV1BDNU1MbHd1cEM3WUwyQXZiQzkwTGhReVRESm9Nb3d6aElYSnlBS0FRS1VjQU80Q3VBSzVBZ0FGamJuSUFuUXVnQzZNTDlTRjBaVlJoWndBQW9Pc25jZ0Iwb0tBaGJBQUFvQllwZ0FGaFpYa0Fyd3V5QzdVTDhpRnZibGhoNUNGcGJGWmhJR1Iyb0J3aFpTSnljMlVBQUFGRlZiOEx6d3NBQVd4eHd3dklDK1VpYldWdWRBQ2dDeUwxSkdsc2FXSnlhWFZ0QUtETElYQW1SWEYxYVd4cFluSnBkVzBBQUtCdktYSUFBS0FjSVc4QW9XUG5JV2gwQUFSQlEwUkdWRlZXWWV3TENnd1FERElNTnd4ZURId005Z0lBQVc1eThBdjRDMmNsYkdWQ2NtRmphMlYwQUFDZzZTZnlJVzkzQUtHU0lVSk0vd3NEREdFQWNnQUFvT1VoWlNSbWRFRnljbTkzQUFDZ3hDRmxJMmxzYVc1bkFBQ2dDU052QVBVQkZnd0FBQjRNWWlWc1pVSnlZV05yWlhRQUFLRG5KMjRBMUFFakRBQUFLZ3hsSkdWV1pXTjBiM0lBQUtCZEtlVWlZM1J2Y2tLZ3dpRmhBSElBQUtCVktXd2liMjl5QUFDZ0N5TUFBV1Z5T3d4TERHVUFBS0dpSWtGV1FReEdESElpY205M0FBQ2dwaUhsSW1OMGIzSUFvRnNwYVNOaGJtZHNaUUJDb3JNaVZnd0FBQUFBV2d4aEFISUFBS0RRS1hFaWRXRnNBQUNndFNKd0FJQUJSRlJXQUdVTWJBeHpETzhrZDI1V1pXTjBiM0lBb0U4cFpTUmxWbVZqZEc5eUFBQ2dYQ25sSW1OMGIzSkNvTDRoWVFCeUFBQ2dWQ25sSW1OMGIzSkNvTUFoWVFCeUFBQ2dVeWtBQVhCMWlReU1ER1lBQUtBZEllNGtaRWx0Y0d4cFpYTUFvSEFwNlNSbmFIUmhjbkp2ZHdDZzJ5RUFBV05vbmd5aERISUFBS0FiSVFDZ3NTSHNKR1ZFWld4aGVXVmtBS0QwS1lBR1NFOWhZMlpvYVcxdmNYTjBkUUMvRE1nTXpBelFET0lNNWd3S0RRME5GQTBaRFU4TlZBMVlEUUFCUTJQRERNWU15Q0ZqZVNsa2VRQW9aRVlpVkdONUFDeGtZeUoxZEdVQVdtRUFvcndxWVdWcGVkZ00yd3plRE9FTThpRnZibUJoNUNGcGJGNWhjZ0JqQUZ4aElXUnlBQURnTmRnVzNlOGhjblFBQWtSTVVsWHZEUFlNL1F3RURXOGtkMjVCY25KdmR3QUFvSk1oWlNSbWRFRnljbTkzQUFDZ2tDSHBKR2RvZEVGeWNtOTNBS0NTSVhBalFYSnliM2NBQUtDUkllY2hiV0dqWStFa2JHeERhWEpqYkdVQW9CZ2ljQUJtQUFEZ05kaEszWElDSHcwQUFBQUFJZzEwQUFDZ0dpTGhJWEpsZ0tHaEpVbFRWUUFxRFRJTlNnM3VKWFJsY25ObFkzUnBiMjRBb0pNaWRRQUFBV0p3TncxQURmTWhaWFJGb0k4aWNTSjFZV3dBQUtDUkl1VWljbk5sZEVXZ2tDSnhJblZoYkFBQW9KSWliaUpwYjI0QUFLQ1VJbU1BY2dBQTREWFlydHhoQUhJQUFLREdJZ0FDWW1OdGNGOE5hZzJPRFpBTmM2RFFJbVVBZEFCRm9OQWljU0oxWVd3QUFLQ0dJZ0FCWTJodURZa05aU0psWkhNQWdLRjdJa1ZUVkFCNERYME5oQTF4SW5WaGJBQUFvTEFxN0NSaGJuUkZjWFZoYkFDZ2ZTSnBJbXhrWlFBQW9IOGlWQUJvQUdFQTlBREhDd0NnRVNJQW9kRWlaWE9WRFo4TmNpSnpaWFFBUmFDREluRWlkV0ZzQUFDZ2h5SmxBSFFBQUtEUklvQUZTRkpUWVdObWFHbHZjbk1BdFEyN0RiOE55QTNPRGRzTjN3MytEUmdPSFE0akRrOEFVZ0JPQUR1QTNnRGVRTUVoUkVVQW9DSWhBQUZJWThNTnhnMWpBSGtBQzJSNUFDWmtBQUZpZGN3TnpRMEpZS1JqZ0FGaFpYa0ExQTNYRGRvTjhpRnZibVJoNUNGcGJHSmhJbVJ5QUFEZ05kZ1gzUUFCWlduakRlNE44Z0hvRFFBQTdRM2xJbVp2Y21VQW9EUWlZUUNZWXdBQlkyN3lEZmtOYXlOVGNHRmpaUUFBNEY4Z0NpRFRJbkJoWTJVQW9Ba2c3Q0ZrWllDaFBDSkZSbFFBQnc0TURoTU9jU0oxWVd3QUFLQkRJblVrYkd4RmNYVmhiQUFBb0VVaWFTSnNaR1VBQUtCSUluQUFaZ0FBNERYWVM5M3BJM0JzWlVSdmRBQ2cyeUFBQVdOMEp3NHJEbklBQU9BMTJLL2M4aUZ2YTJaaDRRcEZEbFlPWUE1cURnQUFiZzV5RGdBQUFBQUFBQUFBQUFCNURud09xQTZ6RGdBQURnOFJEeFlQR2c4QUFXTnlTQTVPRG5VQWRBQmxBRHVBMmdEYVFISUFiNkNmSWVNaGFYSUFvRWtwY2dEakFWc09BQUJkRG5rQURtUjJBR1VBYkdFQUFXbDVZdzVvRG5JQVl3QTdnTnNBMjBBalpHSWliR0ZqQUhCaGNnQUE0RFhZR04xeUFHRUFkZ0JsQUR1QTJRRFpRT0VoWTNKcVlRQUJaR2wvRHA4T1pRQnlBQUFCUWxDRkRwY09BQUZoY29rT2l3NXlBRjlnWVFCakFBQUJaV3VSRHBNT0FLRGZJMlVBZEFBQW9MVWpZU1Z5Wlc1MGFHVnphWE1BQUtEZEkyOEFiZ0JRb01NaTdDRjFjd0NnamlJQUFXZHdxdzZ1RG04QWJnQnlZV1lBQU9BMTJFemRBQVJCUkVWVVlXUndjNzhPMGc3WkR1RU9CUVBxRHZNT0J3OXlJbkp2ZHdEQ29aRWh5QTRBQU13T1lRQnlBQUNnRWlsdkpIZHVRWEp5YjNjQUFLREZJVzhrZDI1QmNuSnZkd0FBb0pVaGNTVjFhV3hwWW5KcGRXMEFBS0J1S1dVQVpRQkJvS1VpY2lKeWIzY0FBS0NsSVc4QWR3QnVBR0VBY2dCeUFHOEE5d0FRQTJVQWNnQUFBVXhTK1E0QUQyVWtablJCY25KdmR3QUFvSlloNlNSbmFIUkJjbkp2ZHdDZ2x5RnBBR3lnMGdOdkFHNEFwV1BwSVc1bmJtRmpBSElBQU9BMTJMRGNhU0pzWkdVQWFHRnRBR3dBTzREY0FOeEFnQVJFWW1Oa1pXWnZjM1lBTFE4eER6VVBOdzg5RDNJUGRnOTdENEFQNFNGemFBQ2dxeUpoQUhJQUFLRHJLbmtBRW1UaElYTm9iS0NwSWdDZzVpb0FBV1Z5UVE5RER3Q2d3U0tBQVdKMGVRQkpEMDBQYXc5aEFISUFBS0FXSUdtZ0ZpRGpJV0ZzQUFKQ1RGTlVXQTljRDE4UFpnOWhBSElBQUtBakl1a2hibVY4WUdVa2NHRnlZWFJ2Y2dBQW9GZ25hU0pzWkdVQUFLQkFJdFFrYUdsdVUzQmhZMlVBb0FvZ2NnQUE0RFhZR2Qxd0FHWUFBT0ExMkUzZFl3QnlBQURnTmRpeDNHUWlZWE5vQUFDZ3FpS0FBbU5sWm05ekFJNFBrUStWRDVrUG5nL3BJWEpqZEdIa0lXZGxBS0RBSW5JQUFPQTEyQnJkY0FCbUFBRGdOZGhPM1dNQWNnQUE0RFhZc3R3QUFtWnBiM09xRDY0UHJ3KzBEM0lBQU9BMTJCdmRubU53QUdZQUFPQTEyRS9kWXdCeUFBRGdOZGl6M0lBRVFVbFZZV05tYjNOMUFNZ1B5dy9PRDlFUDJBL2dEK1FQNlEvdUQyTUFlUUF2WkdNQWVRQUhaR01BZVFBdVpHTUFkUUIwQUdVQU80RGRBTjFBQUFGcGVkd1Azdzl5QUdNQWRtRXJaSElBQU9BMTJCemRjQUJtQUFEZ05kaFEzV01BY2dBQTREWFl0Tnh0QUd3QWVHRUFCRWhoWTJSbFptOXovZzhCRUFVUURSQVFFQjBRSUJBa0VHTUFlUUFXWkdNaWRYUmxBSGxoQUFGaGVRa1FEQkR5SVc5dWZXRVhaRzhBZEFCN1lmSUJGUkFBQUJ3UWJ3QlhBR2tBWkFCMEFPZ0FWQWhoQUpaamNnQUFvQ2doY0FCbUFBQ2dKQ0ZqQUhJQUFPQTEyTFhjNFF0Q0VFa1FUUkFBQUdjUWJSQnlFQUFBQUFBQUFBQUFlUkNLRUpjUThoRDlFQUFBR3hFaEVUSVJPUkVBQUQ0Ull3QjFBSFFBWlFBN2dPRUE0VUJ5SW1WMlpRQURZWUNpUGlKRlpHbDFlUUJXRUZrUVd4QmdFR1VRQU9BK0lqTURBS0EvSW5JQVl3QTdnT0lBNGtCMEFHVUFPNEMwQUxSQU1HUnNBR2tBWndBN2dPWUE1a0J5b0dFZ0FPQTEyQjdkY2dCaEFIWUFaUUE3Z09BQTRFQUFBV1Z3ZkJDR0VBQUJabkNBRUlRUTh5RjViUUNnTlNIb0FJTVFhQUJoQUxGakFBRmhjSTBRV3dBQUFXTnNrUkNURUhJQUFXRm5BQUNnUHlwa0Fwd1FBQUFBQUxFUUFLSW5JbUZrYzNhakVLY1FxUkN1RUc0QVpBQUFvRlVxQUtCY0ttd2liM0JsQUFDZ1dDb0FvRm9xQUtNZ0ltVnNiWEp6ZXJzUXZSREFFTjBRNVJEdEVBQ2dwQ2xsQUFDZ0lDSnpBR1FBWWFBaEltRUV6aERRRU5JUTFCRFdFTmdRMmhEY0VBQ2dxQ2tBb0trcEFLQ3FLUUNncXlrQW9Ld3BBS0N0S1FDZ3Jpa0FvSzhwZEFCMm9COGlZZ0Jrb0w0aUFLQ2RLUUFCY0hUcEVPd1FhQUFBb0NJaXhXRGhJWEp5QUtCOEl3QUJaM0QxRVBnUWJ3QnVBQVZoWmdBQTREWFlVdDBBbzBnaVJXRmxhVzl3QnhFSkVRMFJEeEVTRVJRUkFLQndLdU1oYVhJQW9HOHFBS0JLSW1RQUFLQkxJbk1BSjJEeUlXOTRaYUJJSXZFQURoRnBBRzRBWndBN2dPVUE1VUNBQVdOMGVRQW1FU29SS3hGeUFBRGdOZGkyM0NwZ2JRQndBR1dnU0NMeEFQZ0JhUUJzQUdRQVpRQTdnT01BNDBCdEFHd0FPNERrQU9SQUFBRmphVUVSUnhGdkFHNEFhUUJ1QVBRQTZBRnVBSFFBQUtBUktnQUlUbUZpWTJSbFptbHJiRzV2Y0hKemRXUVJhQkdYRVo4UnB4R3JFZElSMWhFckVqQVNleEtLRW4wUlRoTmJFM29UYndCMEFBQ2c3U29BQVdOeWJCR0pFV3NBQUFKalpYQnpkQkY0RVgwUmdoSHZJVzVuQUtCTUluQWpjMmxzYjI0QTltTnlJbWx0WlFBQW9EVWdhUUJ0QUdXZ1BTSnhBQUNnelNKMkFZMFJrUkZsQUdVQUFLQzlJbVVBWkFCbm9BVWpaUUFBb0FVamNnQnJBSFNndFNQaUlYSnJBS0MySXdBQmIzbWpFYVlSYmdEbkFIY1JNV1R4SVhWdkFLQWVJSUFDWTIxd2NuUUF0Qkc1RWI0UndSSEZFZUVoZFhQbG9EVWk1QUJ3SW5SNWRnQUFvTEFwY3dEcEFIMFJiZ0J2QVBVQTZnQ0FBV0ZvZHdETEVjd1J6aEd5WXdDZ05pSGxJV1Z1QUtCc0luSUFBT0ExMkIvZFp3Q0FBMk52YzNSMWRuY0E0eEh5RVFVU0VoSWhFaVlTS1JLQUFXRnBkUURwRWVzUjd4SHdBS01GY2dCakFBQ2c3eVZ3QUFDZ3d5S0FBV1J3ZEFENEVmd1JBQkp2QUhRQUFLQUFLdXdoZFhNQW9BRXFhU0p0WlhNQUFLQUNLbkVDQ3hJQUFBQUFEeExqSVhWd0FLQUdLbUVBY2dBQW9BVW04aU5wWVc1bmJHVUFBV1IxR2hJZUV1OGhkMjRBb0wwbGNBQUFvTE1sY0NKc2RYTUFBS0FFS21VQTVRQkNEK1VBa2c5aEluSnZkd0FBb0EwcGdBRmhhMjhBTmhKb0VuY1NBQUZqYmpvU1pSSnJBSUFCYkhOMEFFRVNSeEpORW04amVtVnVaMlVBQUtEcktYRUFkUUJoQUhJQTVRQmNCUElqYVdGdVoyeGxnS0cwSldSc2NnQllFbHdTWUJMdklYZHVBS0MrSmVVaFpuUUFvTUlsYVNKbmFIUUFBS0M0SldzQUFLQWpKTEVCYlJJQUFIVVNzZ0Z4RWdBQWN4SUFvSklsQUtDUkpUUUFBS0NUSldNQWF3QUFvSWdsQUFGbGIzOFNoeEp4NEQwQTVTRDFJV2wyQU9CaEl1VWdkQUFBb0JBakFBSndkSGQ0a1JLVkVwc1NueEptQUFEZ05kaFQzWFNncFNKdkFHMEFBS0NsSXZRaGFXVUFvTWdpQUFaRVNGVldZbVJvYlhCMGRYYXlFc0VTMFJMZ0V2Y1MreElLRXhvVEh4TWpFeWdUTnhNQUFreFNiSEs1RXJzU3ZSSy9FZ0NnVnlVQW9GUWxBS0JXSlFDZ1V5VUFvbEFsUkZWa2Rja1N5eExORXM4U0FLQm1KUUNnYVNVQW9HUWxBS0JuSlFBQ1RGSnNjdGdTMmhMY0V0NFNBS0JkSlFDZ1dpVUFvRndsQUtCWkpRQ2pVU1ZJVEZKb2JITHJFdTBTN3hMeEV2TVM5UklBb0d3bEFLQmpKUUNnWUNVQW9Hc2xBS0JpSlFDZ1h5VnZBSGdBQUtESktRQUNURkpzY2dJVEJCTUdFd2dUQUtCVkpRQ2dVaVVBb0JBbEFLQU1KUUNpQUNWRVZXUjFFaE1VRXhZVEdCTUFvR1VsQUtCb0pRQ2dMQ1VBb0RRbGFTSnVkWE1BQUtDZkl1d2hkWE1Bb0o0aWFTSnRaWE1BQUtDZ0lnQUNURkpzY2k4VE1STXpFelVUQUtCYkpRQ2dXQ1VBb0JnbEFLQVVKUUNqQWlWSVRGSm9iSEpDRTBRVFJoTklFMG9UVEJNQW9Hb2xBS0JoSlFDZ1hpVUFvRHdsQUtBa0pRQ2dIQ1VBQVdWMlVoTlZFM1lBNVFENUFHSUFZUUJ5QUR1QXBnQ21RQUFDWTJWcGIySVRaaE5xRTI0VGNnQUE0RFhZdDl4dEFHa0FBS0JQSUcwQTVhQTlJb2dSYkFBQW9Wd0FZbWgwRTNZVEFLREZLZk1oZFdJQW9NZ25iQUYrRTRRVGJBQmxvQ0lnZEFBQW9DSWdjQUFBb1U0aVJXV0pFNHNUQUtDdUt2R2dUeUk4QmVFTXFSTUFBTjhUQUJRREZCOFVBQUFqRkRRVUFBQUFBSVVVQUFBQUFJMFVBQUFBQU5jVTR4VDNGUHNVQUFDSUZRQUFsaFdBQVdOd2NnQ3VFN0VUMVJQMUlYUmxCMkdBb2lraVlXSmpaSE1BdXhPL0U4UVR6aFBTRTI0QVpBQUFvRVFxY2lKamRYQUFBS0JKS2dBQllYWElFOHNUY0FBQW9Fc3FjQUFBb0VjcWJ3QjBBQUNnUUNvQTRDa2lBUDRBQVdWdjJSUGNFM1FBQUtCQklPNEFCQVVBQW1GbGFYWGxFKzhUOVJQNEUvQUI2aE1BQU8wVGN3QUFvRTBxYndCdUFBMWhaQUJwQUd3QU80RG5BT2RBY2dCakFBbGhjQUJ6QUhPZ1RDcHRBQUNnVUNwdkFIUUFDMkdBQVdSdGJnQUlGQTBVRWhScEFHd0FPNEM0QUxoQWNDSjBlWFlBQUtDeUtYUUFBSUdpQUR0bEdCUVpGS0pBY2dCa0FHOEE5QUJpQVhJQUFPQTEyQ0RkZ0FGalpXa0FLQlFxRkRJVWVRQkhaR01BYXdCdG9CTW40U0Z5YXdDZ0V5ZkhZM0lBQUtQTEpVVmpaV1p0Y3o4VVFSUkhGSGNVZkJTQUZBQ2d3eWtBb2NZQ1pXeEdGRWtVY1FBQW9GY2laUUJoQWxBVUFBQUFBR0FVY2lKeWIzY0FBQUZzY2xZVVdoVGxJV1owQUtDNklXa2laMmgwQUFDZ3V5R0FBbEpUWVdOa0FHZ1VhUlJyRkc4VWN4U3VZQUNneUNSekFIUUFBS0NiSXVraGNtTUFvSm9pNFNGemFBQ2duU0p1SW1sdWRBQUFvQkFxYVFCa0FBQ2c3eXJqSVdseUFLRENLZlVoWW5OMW9HTW1hUUIwQUFDZ1l5YnNBcE1VbWhTMkZBQUF3eFJ2QUc0QVphQTZBUEdnVkNLckFHMENueFFBQUFBQW94UmhBSFNnTEFCQVlBQ2hBU0ptYktjVXFSVHVBQk1OWlFBQUFXMTRyaFN5Rk9VaGJuUUFvQUVpWlFEekFOSUI1d0c2RkFBQXdCUmtvRVVpYndCMEFBQ2diU3B1QVBRQXpBR0FBV1p5ZVFESUZNc1V6aFFBNERYWVZOMXZBT1FBMXdFQWdha0FPM01lQWRNVWNnQUFvQmNoQUFGaGI5b1UzaFJ5QUhJQUFLQzFJWE1BY3dBQW9CY25BQUZqZGVZVTZoUnlBQURnTmRpNDNBQUJZbkR1RlBJVVphRFBLZ0NnMFNwbG9OQXFBS0RTS3VRaGIzUUFvTzhpZ0FOa1pXeHdjblozQUFZVkVCVWJGU0VWUkJWbEZZUVY0U0Z5Y2dBQmJISU1GUTRWQUtBNEtRQ2dOU2x3QWhZVkFBQUFBQmtWY2dBQW9ONGlZd0FBb044aTRTRnljbkNndGlFQW9EMHBnS0lxSW1KalpHOXpBQ3NWTUJVNkZUNFZRUlZ5SW1OaGNBQUFvRWdxQUFGaGRUUVZOeFZ3QUFDZ1JpcHdBQUNnU2lwdkFIUUFBS0NOSW5JQUFLQkZLZ0RnS2lJQS9nQUNZV3h5ZGtzVlVSVnVGWE1WY2dCeUFHMmd0eUVBb0R3cGVRQ0FBV1YyZHdCWUZXVVZhUlZ4QUhBQ1h4VUFBQUFBWXhWeUFHVUE0d0FYRlhVQTR3QVpGV1VBWlFBQW9NNGlaU0prWjJVQUFLRFBJbVVBYmdBN2dLUUFwRUJsSTJGeWNtOTNBQUFCYkhKN0ZYOFY1U0ZtZEFDZ3RpRnBJbWRvZEFBQW9MY2haUURrQUcwVkFBRmphWXNWa1JWdkFHNEFhUUJ1QVBRQWt3RnVBSFFBQUtBeEltd2lZM1I1QUFDZ0xTT0FDVUZJWVdKalpHVm1hR2xxYkc5eWMzUjFkM29BdUJXN0ZiOFYxUlhnRmVnVitSVUtGaFVXSHhaVUZsY1daUmJGRnRzVzd4YjdGZ1VYQ2hkeUFQSUF0QUpoQUhJQUFLQmxLUUFDWjJ4eWM4WVZ5aFhPRmRBVjV5RmxjZ0NnSUNEbElYUm9BS0E0SWZJQTlReG9BSGFnRUNBQW9LTWlhd0haRmQ0VllTSnliM2NBQUtBUEtXRUE0d0JmQWdBQllYbmtGZWNWOGlGdmJnOWhOR1FBb1VZaFlXL3RGZlFWQUFGbmNpRUM4UlZ5QUFDZ3lpRjBJbk5sY1FBQW9IY3FnQUZuYkcwQS94VUNGZ1VXTzRDd0FMQkFkQUJoQUxSamNDSjBlWFlBQUtDeEtRQUJhWElPRmhJVzh5Rm9kQUNnZnlrQTREWFlJZDFoQUhJQUFBRnNjaHNXSFJZQW9NTWhBS0RDSVlBQ1lXVm5jM1lBS0JhdUFqWVdPaFkrRm0wQUFLSEVJbTl6TGhZMEZtNEFaQUJ6b01RaTlTRnBkQUNnWmlaaEltMXRZUURkWTJrQWJnQUFvUElpQUtIM0FHbHZReFpSRm1RQVpRQUFnZmNBTzI5S0Zrc1c5MEJ1STNScGJXVnpBQUNneHlKdUFQZ0FVQlpqQUhrQVVtUmpBRzhDWGhZQUFBQUFZaFp5QUc0QUFLQWVJMjhBY0FBQW9BMGpnQUpzY0hSMWR3QnVGbkVXZFJhU0ZwNFc3Q0ZoY2lSZ1pnQUE0RFhZVmQwQW90a0NaVzF3YzMwV2hCYUpGbzBXY1FCa29GQWlid0IwQUFDZ1VTSnBJbTUxY3dBQW9EZ2k3Q0YxY3dDZ0ZDTHhJblZoY21VQW9LRWlZZ0JzQUdVQVlnQmhBSElBZHdCbEFHUUFad0RsQU5jQWJnQ0FBV0ZrYUFDbEZxb1d0Qlp5QUhJQWJ3RDNBUFVNYndCM0FHNEFZUUJ5QUhJQWJ3QjNBUE1BOHhWaEkzSndiMjl1QUFBQmJISzhGc0FXWlFCbUFQUUFIQlpwQUdjQWFBRDBBQjRXWWdISkZzOFdhd0JoQUhJQWJ3RDNBSklMYndMVUZnQUFBQURZRm5JQWJnQUFvQjhqYndCd0FBQ2dEQ09BQVdOdmRBRGhGdWtXN0JZQUFYSjU1UmJvRmdEZ05kaTUzRlZrYkFBQW9QWXA4aUZ2YXhGaEFBRmtjdk1XOXhadkFIUUFBS0R4SW1rQTVxQy9KVnNTQUFGaGFQOFdBaGR5QVBJQU5RTmhBUElBMXd2aEltNW5iR1VBb0tZcEFBRmphUTRYRUJkNUFGOWs1eUp5WVhKeUFLRC9Kd0FKUkdGalpHVm1aMnh0Ym05d2NYSnpkSFY0TVJjNEYwWVhXeGN5QkY0WGFSZDVGNDBYckJlMEY3OFgyUmNWR0NFWUxSZzFHRUFZQUFGRWJ6VVhnUlp2QVBRQStCVUFBV056UEJkQ0YzVUFkQUJsQUR1QTZRRHBRUFFoWlhJQW9HNHFBQUpoYVc5NVRSZFFGMVlYV2hmeUlXOXVHMkZ5QUdPZ1ZpSTdnT29BNmtEc0lXOXVBS0JWSWsxa2J3QjBBQmRoQUFGRWNtSVhaaGR2QUhRQUFLQlNJZ0RnTmRnaTNYS2htaXB1RjNRWFlRQjJBR1VBTzREb0FPaEFaS0NXS204QWRBQUFvSmdxZ0tHWkttbHNjd0NBRjRVWGh4ZnVJblJsY25NQW9PY2pBS0FUSVdTZ2xTcHZBSFFBQUtDWEtvQUJZWEJ6QUpNWGxoZWlGMk1BY2dBVFlYUUFlUUJ6b2dVaW54Y0FBQUFBb1JkbEFIUUFBS0FGSW5BQU1hQURJRE1CcVJlckZ3Q2dCQ0FBb0FVZ0FBRm5jN0FYc1JkTFlYQUFBS0FDSUFBQlozQzRGN3NYYndCdUFCbGhaZ0FBNERYWVZ0MkFBV0ZzY3dERkY4c1h6eGR5QUhPZzFTSnNBQUNnNHlsMUFITUFBS0J4S21rQUFLRzFBMngyMVJmWUYyOEFiZ0MxWS9WakFBSmpjM1YyNEJmb0YvMFhFQmdBQVdsdjVCZFdGM0lBWXdBQW9GWWlhUUx1RndBQUFBRHdGKzBBRFFUaElXNTBBQUZuYlBVWCtSZDBBSElBQUtDV0t1VWhjM01Bb0pVcWdBRmhaV2tBQXhnR0dBb1liQUJ6QUQxZ2N3QjBBQUNnWHlKMkFFU2dZU0pFQUFDZ2VDcndJbUZ5YzJ3QW9PVXBBQUZFWVJrWUhSaHZBSFFBQUtCVEluSUFjZ0FBb0hFcGdBRmpaR2tBSnhncUdPMFhjZ0FBb0M4aGJ3RDBBSXdDQUFGaGFERVlNaGkzWXp1QThBRHdRQUFCYlhJNUdEMFliQUE3Z09zQTYwQnZBQUNnckNDQUFXTnBjQUJHR0VnWVN4aHNBQ0ZnY3dEMEFDd0VBQUZsYjA4WVZ4aGpBSFFBWVFCMEFHa0Fid0R1QUJvRWJnQmxBRzRBZEFCcEFHRUFiQURsQURNRTRRbDFHQUFBZ1JnQUFJTVlpQmdBQUFBQW9SaWxHQUFBcWhnQUFMc1l2aGpSR0FBQTF4Z25HV3dBYkFCcEFHNEFad0JrQUc4QWRBQnpBR1VBOFFCbEYza0FSR1J0SW1Gc1pRQUFvRUFtZ0FGcGJISUFqUmlSR0owWTdDRnBad0NnQS90cEFwY1lBQUFBQUpvWVp3QUFvQUQ3YVFCbkFBQ2dCUHNBNERYWUk5M3NJV2xuQUtBQisrd2hhV2NBNEdZQWFnQ0FBV0ZzZEFDdkdMSVl0aGgwQUFDZ2JTWnBBR2NBQUtBQysyNEFjd0FBb0xFbGJ3Qm1BSkpoOEFIQ0dBQUF4aGhtQUFEZ05kaFgzUUFCWVd2SkdNd1liQURzQUdzRWRxRFVJZ0NnMlNwaEkzSjBhVzUwQUFDZ0RTb0FBV0Z2MmhnaUdRQUJZM1BlR0I4WnNRUG5HUDBZQlJrU0dSVVpBQUFkR2JJRDd4anlHUFFZOXhqNUdBQUEreGc3Z0wwQXZVQUFvRk1oTzRDOEFMeEFBS0JWSVFDZ1dTRUFvRnNoc3dFQkdRQUFBeGtBb0ZRaEFLQldJYlFDQ3hrT0dRQUFBQUFRR1R1QXZnQytRQUNnVnlFQW9Gd2hOUUFBb0ZnaHRnRVpHUUFBR3hrQW9Gb2hBS0JkSVRnQUFLQmVJV3dBQUtCRUlIY0FiZ0FBb0NJall3QnlBQURnTmRpNzNJQUlSV0ZpWTJSbFptZHBhbXh1YjNKemRIWUFSaGxLR1ZvWlhobG1HV2taa2htV0daa1puUm1nR2EwWnhobkxHYzhaNEJrakdteWdaeUlBb0l3cWdBRmpiWEFBVUJsVEdWZ1o5U0YwWmZWaGJRQmhBT1Nnc3dNNkZnQ2doaXB5SW1WMlpRQWZZUUFCYVhsaUdXVVpjZ0JqQUIxaE0yUnZBSFFBSVdHQW9XVWliSEZ6QU1ZRWNCbDZHZkdoWlNMT0JBQUFkaGxzQUdFQWJnRDBBTjhFZ0tGK0ttTmtiQUNCR1lRWmpCbGpBQUNncVNwdkFIUUFiNkNBS215Z2dpb0FvSVFxWmVEYklnRCtjd0FBb0pRcWNnQUE0RFhZSk4zbm9Hc2lyQVR0SVdWc0FLQTNJV01BZVFCVFpJQ2hkeUpGWVdvQXB4bXBHYXNaQUtDU0tnQ2dwU29Bb0tRcUFBSkZZV1Z6dEJtMkdiMFp3aGtBb0draWNBQndvSW9xOGlGdmVBQ2dpaXB4b0lncThhQ0lLclVaYVFCdEFBQ2c1eUp3QUdZQUFPQTEyRmpkWVFCMkFPVUFZd0lBQVdOcDB4bldHWElBQUtBS0lXMEFBS0Z6SW1WczNCbmVHUUNnamlvQW9KQXFBSU0rQUR0alpHeHhjbzBFNnhuMEdmZ1ovQmtCR2dBQlkybnZHZkVaQUtDbktuSUFBS0I2S204QWRBQUFvTmNpMENGaGNnQ2dsU2wxSW1WemRBQUFvSHdxZ0FKaFpHVnNjd0FLR3ZRWkZoclZCQ0FhOEFFUEdnQUFGQnB3QUhJQWJ3RDRBRmtaY2dBQW9IZ3BjUUFBQVd4eHhBUWJHbXdBWlFCekFQTUFTUmxwQU8wQTVBUUFBV1Z1SnhvdUduSWpkRzVsY1hFQUFPQnBJZ0QreFFBc0dnQUZRV0ZpWTJWbWEyOXplVUFhUXhwbUdtb2FiUnFER29jYWxockNHdE1hY2dEeUFNd0NBQUpwYkcxeVNocE9HbEFhVkJweUFITUE4QUJ4RDJZQXZXQnBBR3dBOUFBU0JRQUJaSEpZR2xzYVl3QjVBRXBrQUtHVUlXTjNZQnBrR21rQWNnQUFvRWdwQUtDdElXRUFjZ0FBb0E4aDZTRnlZeVZoZ0FGaGJISUFjeHA3R244YThpRjBjM1dnWlNacEFIUUFBS0JsSnV3aGFYQUFvQ1lnNHlGdmJnQ2d1U0p5QUFEZ05kZ2wzWE1BQUFGbGQ0d2FrUnBoSW5KdmR3QUFvQ1VwWVNKeWIzY0FBS0FtS1lBQ1lXMXZjSElBbnhxakdxY2F1aHErR25JQWNnQUFvUDhoOUNGb2RBQ2dPeUpyQUFBQmJIS3NHck1hWlNSbWRHRnljbTkzQUFDZ3FTSHBKR2RvZEdGeWNtOTNBS0NxSVdZQUFPQTEyRm5kNGlGaGNnQ2dGU0NBQVdOc2RBRElHc3dhMEJweUFBRGdOZGk5M0dFQWN3RG9BR2thOGlGdmF5ZGhBQUZpY05jYTJ4cjFJV3hzQUtCRElPZ2haVzRBb0JBZzRRcjJHZ0FBL1JvQUFBZ2JFeHNhR3dBQUlSczdHd0FBQUFBK0cySWJtUnVWRzZzYkFBQ3lHODBiMGh0akFIVUFkQUJsQUR1QTdRRHRRQUNoWXlCcGVRRWJCaHR5QUdNQU80RHVBTzVBT0dRQUFXTjRDeHNORzNrQU5XUmpBR3dBTzRDaEFLRkFBQUZtY3NzQ0Zoc0E0RFhZSnQxeUFHRUFkZ0JsQUR1QTdBRHNRSUNoU0NGcGJtOEFKeHN5R3pZYkFBRnBiaXNiTHh0dUFIUUFBS0FNS25RQUFLQXRJdVloYVc0QW9Od3BkQUJoQUFDZ0tTSHNJV2xuTTJHQUFXRnZjQUJERzFzYlhodUFBV05uZEFCSkcwc2JXUnR5QUN0aGdBRmxiSEFBY1FWUkcxVWJhUUJ1QU9VQXlBVmhBSElBOUFCeUJXZ0FNV0ZtQUFDZ3R5SmxBR1FBdFdFQW9nZ2lZMlp2ZEdrYmJSdDFHM2tiNFNGeVpRQ2dCU0ZwQUc0QWRLQWVJbWtBWlFBQW9OMHBaQUJ2QVBRQVd4c0FvaXNpWTJWc2NJRWJoUnVQRzVRYllRQnNBQUNndWlJQUFXZHlpUnVORzJVQWNnRHpBQ01RNHdDQ0cyRWljbWhyQUFDZ0Z5cnlJVzlrQUtBOEtnQUNZMmR3ZEo4Ym9SdWtHNmdiZVFCUlpHOEFiZ0F2WVdZQUFPQTEyRnJkWVFDNVkzVUFaUUJ6QUhRQU80Qy9BTDlBQUFGamFiVWJ1UnR5QUFEZ05kaSszRzRBQUtJSUlrVmtjM2JDRzhRYnlCdlFBd0NnK1NKdkFIUUFBS0QxSW5hZzlDSUFvUE1pYWFCaUlPd2haR1VwWWVzQjFoc0FBTmtiWXdCNUFGWmtiQUE3Z084QTcwQUFBMk5tYlc5emRlWWI3aHZ5Ry9VYitoc0ZIQUFCYVhucUcrMGJjZ0JqQURWaE9XUnlBQURnTmRnbjNlRWhkR2czWW5BQVpnQUE0RFhZVzkzakFmOGJBQUFESEhJQUFPQTEyTC9jOGlGamVWaGs2eUZqZVZSa0FBUmhZMlpuYUdwdmN4VWNHaHdpSENZY0tod3RIREFjTlJ6d0lYQmhkcUM2QS9CakFBRmxlUjRjSVJ6a0lXbHNOMkU2WkhJQUFPQTEyQ2pkY2lKbFpXNEFPR0ZqQUhrQVJXUmpBSGtBWEdSd0FHWUFBT0ExMkZ6ZFl3QnlBQURnTmRqQTNJQUxRVUpGU0dGaVkyUmxabWRvYW14dGJtOXdjbk4wZFhZQVhoeHRISEVjZFJ4NUhOOGNCeDBkSFR3ZDNCM3RIZkVkQVI0RUhoMGVMQjVGSHJ3ZXd4N2hIZ2tmUFI5TEg0QUJZWEowQUdRY1p4eHBISElBOGdCdkIvSUF4UUxoSVdsc0FLQWJLZUVoY25JQW9BNHBaNkJtSWdDZ2l5cGhBSElBQUtCaUtXTUpqUndBQUpBY0FBQ1ZIQUFBQUFBQUFBQUFBQUNaSEp3Y0FBQ21IS2djclJ3QUFOSWM5U0YwWlRwaDdTSndkSGwyQUtDMEtYSUFZUUR1QUZvRzRpRmtZYnRqWndBQW9lZ25aR3loSEtNY0FLQ1JLZVVBaXdZQW9JVXFkUUJ2QUR1QXF3Q3JRSElBZ0tPUUlXSm1hR3h3YzNRQXVoeS9ITUljeEJ6SEhNb2N6aHhtb09RaGN3QUFvQjhwY3dBQW9CMHA2d0N5R25BQUFLQ3JJV3dBQUtBNUtXa0FiUUFBb0hNcGJBQUFvS0loQUtHckttRmwxaHphSEdrQWJBQUFvQmtwYzZDdEtnRGdyU29BL29BQllXSnlBT1VjNlJ6dEhISUFjZ0FBb0F3cGNnQnJBQUNnY2ljQUFXRnI4Uno0SEdNQUFBRmxhL1ljOXh4N1lGdGdBQUZsYy93Yy9od0FvSXNwYkFBQUFXUjFBeDBGSFFDZ2p5a0FvSTBwQUFKaFpYVjVEaDBSSFJvZEhCM3lJVzl1UG1FQUFXUnBGUjBZSFdrQWJBQThZZXdBb3diaUFQY2NPMlFBQW1OeGNuTWtIU2NkTEIwNUhXRUFBS0EyS1hVQWJ3RHlvQndncWhFQUFXUjFNQjAwSGVnaFlYSUFvR2NwY3lKb1lYSUFBS0JMS1dnQUFLQ3lJUUNpWkNKbVozRnpSQjFGQjVRZG5oMTBBSUFDWVdoc2NuUUFUaDFXSFdVZGJCMk5IWElpY205M0FIU2drQ0ZoQU9rQXp4eGhJM0p3YjI5dUFBQUJaSFZlSFdJZDd5RjNiZ0NndlNGd0FBQ2d2Q0hsSkdaMFlYSnliM2R6QUtESElXa2laMmgwQUlBQllXaHpBSFVkZXgyREhYSWljbTkzQVBPZ2xDR2RCbUVBY2dCd0FHOEFid0J1QVBNQXpndHhBSFVBYVFCbkFHRUFjZ0J5QUc4QTl3QmxHdWdrY21WbGRHbHRaWE1Bb01zaThhRmtJazBIQUFDYUhXd0FZUUJ1QVBRQVhnY0FvbjBxWTJSbmM2WWRxUjJ4SGJjZFl3QUFvS2dxYndCMEFHK2dmeXB5b0lFcUFLQ0RLbVhnMmlJQS9uTUFBS0NUS29BQ1lXUmxaM01Bd0IzR0hjb2QxaDNaSFhBQWNBQnlBRzhBK0FDbUhHOEFkQUFBb05ZaWNRQUFBV2R4engzU0hYUUE4Z0JHQjJjQWRBRHlBSFFjZEFEeUFGTUhhUUR0QUdNSGdBRnBiSElBNGgzbUhlb2Q4eUZvZEFDZ2ZDbHZBRzhBOGdES0JnRGdOZGdwM1VXZ2RpSUFvSkVxWVFIMUhmNGRjZ0FBQVdSMVlCMzVIV3lndkNFQW9Hb3BiQUJyQUFDZ2hDVmpBSGtBV1dRQW9tb2lZV05vZEF3ZUR4NFZIaGtlY2dEeUFHc2Rid0J5QUc0QVpRRHlBR0FXNFNGeVpBQ2dheWx5QUdrQUFLRDZKUUFCYVc4aEhpUWU1Q0Z2ZEVCaDlTRnpkR0dnc0NQaklXaGxBS0N3SXdBQ1JXRmxjek1lTlI0OEhrRWVBS0JvSW5BQWNLQ0pLdkloYjNnQW9Ja3FjYUNIS3ZHZ2h5bzBIbWtBYlFBQW9PWWlBQVJoWW01dmNIUjNlbEllWEI1ZkhvVWVsaDZtSHFzZXRCNEFBVzV5Vmg1WkhtY0FBS0RzSjNJQUFLRDlJWElBNndDd0JtY0FnQUZzYlhJQVpoNTJIbnNlNVNGbWRBQUJZWEtJQjJ3ZWFRQm5BR2dBZEFCaEFISUFjZ0J2QVBjQWt3ZmhJbkJ6ZEc4QW9Qd25hUUJuQUdnQWRBQmhBSElBY2dCdkFQY0FtZ2R3STJGeWNtOTNBQUFCYkhLTkhwRWVaUUJtQVBRQXhoeHBJbWRvZEFBQW9Ld2hnQUZoWm13QW5CNmZIcUllY2dBQW9JVXBBT0ExMkYzZGRRQnpBQUNnTFNwcEltMWxjd0FBb0RRcVlRR3ZIck1lY3dCMEFBQ2dGeUxoQUlvT1phSEtKYmtlUmhMdUlXZGxBS0RLSldFQWNnQnNvQ2dBZEFBQW9KTXBnQUpoWTJodGRBRE1IczhlMVI3Ykh0MGVjZ0R5QUowR2J3QnlBRzRBWlFEeUFOWVdZUUJ5QUdTZ3l5RUFvRzBwQUtBT0lISUFhUUFBb0w4aUFBTmhZMmhwY1hUckh1OGUxUWZ6SHYwZUJoL3hJWFZ2QUtBNUlISUFBT0ExMk1IY2JRRGxvWElpK2g0QUFQd2VBS0NOS2dDZ2p5b0FBV0oxOXh3QkgyOEFjcUFZSUFDZ0dpRHlJVzlyUW1FQWhEd0FPMk5rYUdsc2NYSkNCaGNmeGgwZ0h5UWZLQjhzSHpFZkFBRmphUnNmSFI4QW9LWXFjZ0FBb0hrcWNnQmxBT1VBa3gzdElXVnpBS0RKSXVFaGNuSUFvSFlwZFNKbGMzUUFBS0I3S2dBQlVHazFIemtmWVFCeUFBQ2dsaWxsb2NNbEFnZGZFbklBQUFGa2RVSWZSeDl6SW1oaGNnQUFvRW9wNkNGaGNnQ2daaWtBQVdWdVR4OVdIM0lqZEc1bGNYRUFBT0JvSWdEK3hRQlVId0FIUkdGalpHVm1hR2xzYm05d2MzVnVIM0lmb2grckg2OGZ0eCs3SDc0ZjVoL3VIL01mQndqL0h3c2d4Q0Z2ZEFDZ09pSUFBbU5zY0hKNUgzMGZpUitlSDNJQU80Q3ZBSzlBQUFGbGRJRWZneDhBb0VJbVphQWdKM01BWlFBQW9DQW5jNkNtSVhRQWJ3Q0FvYVloWkd4MUFKUWZtQitjSDI4QWR3RHVBSGtEWlFCbUFQUUE2Z2J3QU9rTzZ5RmxjZ0NncmlVQUFXOTVwaCtxSCswaGJXRUFvQ2txUEdUaElYTm9BS0FVSU9FbGMzVnlaV1JoYm1kc1pRQ2dJU0p5QUFEZ05kZ3EzVzhBQUtBbklZQUJZMlJ1QU1RZnlSL2JIM0lBYndBN2dMVUF0VUJob2lNaTBCOEFBTk1mMXg5ekFQUUFLeEZwQUhJQUFLRHdLbThBZEFBN2dMY0F0MEIxQUhNQTRxRVNJaDRUQUFEakgzV2dPQ0lBb0NvcVl3SHFIKzBmY0FBQW9Oc3E4Z0IrR25BQWJBQjFBUE1BQ0FnQUFXUnc5eC83SCtVaGJITUFvS2NpWmdBQTREWFlYdDBBQVdOMEF5QUhJSElBQU9BMTJNTGM4Q0Z2Y3dDZ1BpSnNvYndERUNBVklQUWlhVzFoY0FDZ3VDSmhBUEFBRXlBQURFZE1VbFpoWW1Oa1pXWm5hR2xxYkcxdmNISnpkSFYyZHp3Z1J5Qm1JRzBnZVNDcUlMZ2cyaURlSUJFaEZTRXlJVU1oVFNGUUlad2hueUhTSVFBaUl5S0xJckVpdnlJVUl3QUJaM1JBSUVNZ0FPRFpJamdEOXVCckl0SWdCd21BQVdWc2RBQk5JRjhnWWlCbUFIUUFBQUZoY2xNZ1dDQnlJbkp2ZHdBQW9NMGg2U1JuYUhSaGNuSnZkd0NnemlFQTROZ2lPQVAyNEdvaTBpQmZDZWtrWjJoMFlYSnliM2NBb004aEFBRkVaSEVnZFNEaElYTm9BS0N2SXVFaGMyZ0FvSzRpZ0FKaVkyNXdkQUNDSUlZZ2lTQ05JS0lnYkFCaEFBQ2dCeUwxSVhSbFJHRm5BQURnSUNMU0lBQ2lTU0pGYVc5d2xTQ1lJSndnbmlBQTRIQXFPQU5rQUFEZ1N5STRBM01BU1dGeUFHOEErQUF5Q25VQWNnQmhvRzRtYkFEem9HNG1td2p6QWE4Z0FBQ3pJSEFBTzRDZ0FLQkFiUUJ3QU9YZ1RpSTRBeW9KZ0FKaFpXOTFlUURCSU1vZ3pTRFdJTmtnOEFIR0lBQUF5Q0FBb0VNcWJ3QnVBRWhoNUNGcGJFWmhiZ0JuQUdTZ1J5SnZBSFFBQU9CdEtqZ0RjQUFBb0VJcVBXVGhJWE5vQUtBVElBQ2pZQ0pCWVdSeGMzanBJTzBnK1NEK0lBSWhEQ0Z5QUhJQUFLRFhJWElBQUFGb2N2SWc5U0JyQUFDZ0pDbHZvSmNoOXdBR0QyOEFkQUFBNEZBaU9BTjFBR2tBOWdDN0NBQUJaV2tHSVFvaFlRQnlBQUNnS0NudEFOOEk2U0Z6ZFBPZ0JDTGxDSElBQU9BMTJDdmRBQUpGWlhOMC93Z2NJU3NoTGlIeG9YRWlJaUVBQUJNSjhhRnhJZ0FKQUFBbklXd0FZUUJ1QVBRQUV3bHBBTzBBR1FseW9HOGlBS0J2SW9BQlFXRndBRGdoT3lFL0lYSUE4Z0JlSUhJQWNnQUFvSzRoWVFCeUFBQ2c4aXB6b2dzaVNpRUFBQUFBeHd0a29Qd2lBS0Q2SW1NQWVRQmFaSUFEUVVWaFpHVnpkQUJjSVY4aFlpRm1JV2toa3lHV0lYSUE4Z0JYSUFEZ1ppSTRBM0lBY2dBQW9Kb2hjZ0FBb0NVZ2dLRndJbVp4Y3dCd0lZUWhqaUYwQUFBQllYSjFJWG9oY2dCeUFHOEE5d0JsSVdrQVp3Qm9BSFFBWVFCeUFISUFid0QzQUQ0aDhhRndJbUFoQUFDS0lXd0FZUUJ1QVBRQVp3bHo0SDBxT0FNQW9HNGlhUUR0QUcwSmNxQnVJbWtBNWFEcUlrVUphUURrQURvS0FBRndkS01ocHlGbUFBRGdOZGhmM1lDQnJBQTdhVzRBcmlHdkljY2hyRUJ1QUlDaENTSkZaSFlBdHlHNkliOGhBT0Q1SWpnRGJ3QjBBQURnOVNJNEErRUIxZ2pFSWNZaEFLRDNJZ0NnOWlKcEFIYWdEQ0xoQWFnSnp5SFJJUUNnL2lJQW9QMGlnQUZoYjNJQTJDSHNJZkVoY2dDQW9TWWlZWE4wQU9BaDVTSHBJV3dBYkFCbEFPd0F5d2hzQUFEZy9TcmxJQURnQWlJNEEyd2lhVzUwQUFDZ0ZDcmpvWUFpOXlFQUFQb2hkUURsQUpzSlkrQ3ZLamdEWmFDQUl2RUFrd2tBQWtGaGFYUUhJZ29pRnlJZUluSUE4Z0JzSUhJQWNnQUFvWnNoWTNjUkloUWlBT0F6S1RnREFPQ2RJVGdEWnlSb2RHRnljbTkzQUFDZ215RnlBR2tBNWFEcklyNEpnQU5qYUdsdGNIRjFBQzhpUENKSElwd2hUU0pRSWxvaWdLR0JJbU5sY2dBMkl2MEpPU0oxQU9VQUJnb0E0RFhZdzl6dklYSjBiUUtkSVFBQUFBQkVJbUVBY2dEaEFPRWhiUUJsb0VFaThhQkVJaVlLWVFEeUFNc0ljd0IxQUFBQlluQldJbGdpNVFEVUNlVUEzd21BQVdKamNBQmdJbk1pZUNLQW9ZUWlSV1Z6QUdjaTdnbHFJZ0RneFNvNEEyVUFkQUJsNElJaTBpQnhBUEdnaUNKb0ltTUFaYUNCSXZFQS9nbUFvWVVpUldWekFIOGlGZ3FDSWdEZ3hpbzRBMlVBZEFCbDRJTWkwaUJ4QVBHZ2lTS0FJZ0FDWjJsc2NwSWlsQ0thSXB3aTdBQU1DV3dBWkFCbEFEdUE4UUR4UU9jQVd3bHBJMkZ1WjJ4bEFBQUJiSEtrSXFvaTVTRm1kR1dnNmlMeEFFVUphU0puYUhRQVphRHJJdkVBdmdsdG9MMERBS0VqQUdWenVDSzhJbklBYndBQW9CWWhjQUFBb0FjZ2dBUkVTR0ZrWjJsc2NuTUF6aUxTSXRZaTJpTGVJdWdpN1NJQ0l3OGo0U0Z6YUFDZ3JTTGhJWEp5QUtBRUtYQUFBT0JOSXRJZzRTRnphQUNnckNJQUFXVjA0aUxsSWdEZ1pTTFNJQURnUGdEU0lHNGlabWx1QUFDZzNpbUFBVUZsZEFEekl2Y2kraUp5QUhJQUFLQUNLUURnWkNMU0lITGdQQURTSUdrQVpRQUE0TFFpMGlBQUFVRjBCaU1LSTNJQWNnQUFvQU1wOGlGcFpRRGd0U0xTSUdrQWJRQUE0RHdpMGlDQUFVRmhiZ0FhSXg0aktpTnlBSElBQUtEV0lYSUFBQUZvY2lNakppTnJBQUNnSXlsdm9KWWg5d0QvRHVVaFlYSUFvQ2NwVXhKcUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVZDTUFBRjRqYVNOL0k0SWpqU09lSThBVUFBQUFBS1lqd0NNQUFOb2ozeU1BQU84akhpUXZKRDhrUkNRQUFXTnpWeU5zRkhVQWRBQmxBRHVBOHdEelFBQUJhWGxoSTJjamNnQmpvSm9pTzREMEFQUkFQbVNBQW1GaWFXOXpBSEVqZENOM0kzRUJlaU56QU9nQWRoVHNJV0ZqVVdGMkFBQ2dPQ3J2SVd4a0FLQzhLZXdoYVdkVFlRQUJZM0tGSTRramFRQnlBQUNndnlrQTREWFlMTjF2QTVRakFBQUFBSllqQUFDY0kyNEEyMkpoQUhZQVpRQTdnUElBOGtBQW9NRXBBQUZpYmFFampBcGhBSElBQUtDMUtRQUNZV05wZEt3anJ5TzZJNzBqY2dEeUFGa1VBQUZwY3JNanRpTnlBQUNndmludklYTnpBS0M3S1c0QTVRRFpDZ0Nnd0NtQUFXRmxhUURGSThnanl5TmpBSElBVFdGbkFHRUF5V09BQVdOa2JnRFJJOVFqMWlQeUlXOXV2Mk1Bb0xZcGRRRHpBSGdCY0FCbUFBRGdOZGhnM1lBQllXVnNBT1FqNXlQckkzSUFBS0MzS1hJQWNBQUFvTGtwZFFEekFId0JBS01vSW1Ga2FXOXpkdmtqL0NNUEpCTWtGaVFiSkhJQThnQmVGSUNoWFNwbFptMEFBeVFKSkF3a2NnQnZvRFFoWmdBQW9EUWhPNENxQUtwQU80QzZBTHBBNXlGdlpnQ2d0aUp5QUFDZ1ZpcHNJbTl3WlFBQW9GY3FBS0JiS29BQlkyeHZBQ01rSlNRckpQSUFDQ1JoQUhNQWFBQTdnUGdBK0VCc0FBQ2dtQ0pwQUd3Qk15UTRKR1FBWlFBN2dQVUE5VUJsQUhNQVlhQ1hJbk1BQUtBMkttMEFiQUE3Z1BZQTlrRGlJV0Z5QUtBOUkrRUtYaVFBQUhva0FBQjhKSlFrQUFDWUpLa2tBQUFBQUxVa0VRc0FBUEFrQUFBQUFBUWxlaVVBQUlNbGNnQ0FvU1VpWVhOMEFHVWtieVFCQ3dDQnRnQTdiR29rYXlTMlFHd0FaUURzQUJnRGFRSjFKQUFBQUFCNEpHMEFBS0R6S2dDZy9TcDVBRDlrY2dDQUFtTnBiWEIwQUlVa2lDU0xKSmtTanlSdUFIUUFKV0J2QUdRQUxtQnBBR3dBQUtBd0lPVWhibXNBb0RFZ2NnQUE0RFhZTGQyQUFXbHRid0NkSktBa3BDUjJvTVlEMVdOdEFHRUE5QUQrQjI0QVpRQUFvQTRtOUtIQUE2NGtBQUMwSkdNamFHWnZjbXNBQUtEVUl0WmpBQUZoZGJna3hDUnVBQUFCWTJ1OUpNSWthd0Jvb0E4aEFLQU9JZllBYVJwekFBQ2tLd0JoWW1Oa1pXMXpkTk1rSVJQWEpOc2s0U1RqSk9jazZ5VGpJV2x5QUtBaktta0FjZ0FBb0NJcUFBRnZkWXNXM3lRQW9DVXFBS0J5S200QU80Q3hBTEZBYVFCdEFBQ2dKaXAzQUc4QUFLQW5Lb0FCYVhCMUFQVWsraVQrSk80aWRHbHVkQUNnRlNwbUFBRGdOZGhoM1c0QVpBQTdnS01BbzBDQXBIb2lSV0ZqWldsdWIzTjFBQk1sRlNVWUpSc2xUQ1ZSSlZrbFNTVjFKUUNnc3lwd0FBQ2d0eXAxQU9VQVB3dGpvSzhxZ0tKNkltRmpaVzV6QUNjbExTVTBKVFlsU1NWd0FIQUFjZ0J2QVBnQUZ5VjFBSElBYkFCNUFHVUE4UUEvQy9FQU9BdUFBV0ZsY3dBOEpVRWxSU1h3SW5CeWIzZ0FvTGtxY1FCeEFBQ2d0U3BwQUcwQUFLRG9JbWtBN1FCRUMyMEFaUUR6b0RJZ0lndUFBVVZoY3dCREpWY2xSU1h3QUVBbGdBRmtabkFBVHd0ZkpYRWxnQUZoYkhNQVpTVnBKVzBsN0NGaGNnQ2dMaVBwSVc1bEFLQVNJL1VoY21ZQW9CTWpkS0FkSXU4QVdRdnlJV1ZzQUtDd0lnQUJZMmw5SllFbGNnQUE0RFhZeGR6SVkyNGlZM053QUFDZ0NDQUFBMlpwYjNCemRaRWxLeHVWSlpvbG55V2tKWElBQU9BMTJDN2RjQUJtQUFEZ05kaGkzWElpYVcxbEFBQ2dWeUJqQUhJQUFPQTEyTWJjZ0FGaFpXOEFxaVc2SmNBbGRBQUFBV1ZwcnlXMkpYSUFiZ0JwQUc4QWJnRHpBQmtGYmdCMEFBQ2dGaXB6QUhRQVphQS9BUEVBQ1JqMEFHMExnQXBCUWtoaFltTmtaV1pvYVd4dGJtOXdjbk4wZFhnQTR5WHlKZllsK2lWcEpwQW1waWE5SnRVbTVpYjRKbG9uYUNkeEozVW5uaWV0SjdFbnlDZmlKK2NuZ0FGaGNuUUE2U1hzSmU0bGNnRHlBSmtNOGdENkF1RWhhV3dBb0J3cFlRQnlBUElBM0JWaEFISUFBS0JrS1lBRFkyUmxibkZ5ZEFBR0poQW1FeVlZSmlZbUt5WmFKZ0FCWlhVS0pnMG1BT0E5SWpFRGRBQmxBRlZoYVFEakFDQU43U0p3ZEhsMkFLQ3pLV2NBZ0tIcEoyUmxiQUFnSmlJbUpDWUFvSklwQUtDbEtlVUE5d3QxQUc4QU80QzdBTHRBY2dBQXBaSWhZV0pqWm1oc2NITjBkejBtUUNaRkprY21TaVpNSms0bVVTWlZKbGdtY0FBQW9IVXBacURsSVhNQUFLQWdLUUNnTXlsekFBQ2dIaW5yQUxrYThBQ1ZIbXdBQUtCRktXa0FiUUFBb0hRcGJBQUFvS01oQUtDZElRQUJZV2xlSm1JbWFRQnNBQUNnR2lsdkFHNmdOaUpoQUd3QTh3QjJDNEFCWVdKeUFHOG1jaVoySm5JQThnQXZFbklBYXdBQW9ITW5BQUZoYTNvbWdTWmpBQUFCWld0L0pvQW1mV0JkWUFBQlpYT0ZKb2NtQUtDTUtXd0FBQUZrZFl3bWppWUFvSTRwQUtDUUtRQUNZV1YxZVpjbW1pYWpKcVVtOGlGdmJsbGhBQUZrYVo0bW9TWnBBR3dBVjJIc0FBOE00Z0NBSmtCa0FBSmpiSEZ6clNhd0pyVW11aVpoQUFDZ055bGtJbWhoY2dBQW9Ha3BkUUJ2QVBLZ0hTQ2pBV2dBQUtDeklZQUJZV05uQU1NbTBpYVVDMndBZ0tFY0lXbHdjd0RMSnM0bWlneHVBT1VBb0F4aEFISUE5QURhQzNRQUFLQ3RKWUFCYVd4eUFOc20zeWJqSnZNaGFIUUFvSDBwYndCdkFQSUFOZ3dBNERYWUw5MEFBV0Z2NmliMUpuSUFBQUZrZGU4bThTWUFvTUVoYktEQUlRQ2diQ2wyb01FRDhXT0FBV2R1Y3dEK0prNG5VQ2RvQUhRQUFBTmhhR3h5YzNRS0p4SW5JU2MxSnowblJ5ZHlJbkp2ZHdCMG9KSWhZUURwQUZZbVlTTnljRzl2YmdBQUFXUjFHaWNlSjI4QWR3RHVBUEFtY0FBQW9NQWg1U0ZtZEFBQllXZ25KeTBuY2dCeUFHOEFkd0R6QUFrTVlRQnlBSEFBYndCdkFHNEE4d0FUQkdrbFoyaDBZWEp5YjNkekFBQ2d5U0Z4QUhVQWFRQm5BR0VBY2dCeUFHOEE5d0JaSnVna2NtVmxkR2x0WlhNQW9Nd2lad0RhWW1rQWJnQm5BR1FBYndCMEFITUFaUUR4QUJ3WWdBRmhhRzBBWUNkakoyWW5jZ0R5QUFrTVlRRHlBQk1FQUtBUElHOGlkWE4wQUdHZ3NTUGpJV2hsQUtDeEkrMGhhV1FBb080cUFBSmhZbkIwZkNlR0o0a25tU2NBQVc1eWdDZURKMmNBQUtEdEozSUFBS0QrSVhJQTZ3QWNESUFCWVdac0FJOG5raWVWSjNJQUFLQ0dLUURnTmRoajNYVUFjd0FBb0M0cWFTSnRaWE1BQUtBMUtnQUJZWENpSjZnbmNnQm5vQ2tBZEFBQW9KUXA3eUpzYVc1MEFLQVNLbUVBY2dEeUFEd25BQUpoWTJoeHVDZThKNkVNd0NmeElYVnZBS0E2SUhJQUFPQTEyTWZjQUFGaWRZQW14Q2R2QVBLZ0dTQ29BWUFCYUdseUFNNG4waWZXSjNJQVpRRGxBRTBuN1NGbGN3Q2d5aUpwQUlDaHVTVmxabXdBWEF4akV0NG45Q0Z5YVFDZ3ppbnNJblZvWVhJQW9HZ3BBS0FlSVdFTkJTZ0pLQTBvU3loVktJWW9BQUNMS0xBb0FBQUFBT01vNXlnQUFCQXBKQ2t4S1cwcGNTbUhLYVlwQUFDWUtnQUFBQUN4S21NaWRYUmxBRnRoY1FCMUFPOEFCUitBcEhzaVJXRmpaV2x1Y0hONUFCd29IaWduS0Nvb0x5Z3lLRUVvUmloSktBQ2d0Q3J3QVNNb0FBQWxLQUNndUNwdkFHNEFZV0YxQU9VQWd3MWtvTEFxYVFCc0FGOWhjZ0JqQUYxaGdBRkZZWE1BT0NnNktEMG9BS0MyS25BQUFLQzZLbWtBYlFBQW9Pa2k3eUpzYVc1MEFLQVRLbWtBN1FDSURVRmtid0IwQUdLaXhTS1JGZ0FBQUFCVEtBQ2daaXFBQTBGaFkyMXpkSGdBWUNoa0tHOG9jeWgxS0hrb2dpaHlBSElBQUtEWUlYSUFBQUZvY21rb2F5anJBSkFhYjZDWUlmY0F6QWQwQUR1QXB3Q25RR2tBTzJEM0lXRnlBS0FwS1cwQUFBRnBibjRvelFCdUFIVUE4d0RPQUhRQUFLQTJKM0lBNytBMTJERGRJeGtBQW1GamIzbVJLSlVvblNpc0tISUFjQUFBb0c4bUFBRm9lWmtvbkNoakFIa0FTV1JJWkhJQWRBQnRBcVVvQUFBQUFLZ29hUURrQUZzUFlRQnlBR0VBN0FCc0pEdUFyUUN0UUFBQloyMnpLTHNvYlFCaEFBQ2h3d05tZHJvb3VpakNZNENqUENKa1pXZHNibkJ5QU1nb3pDalBLTk1vMXlqYUtONG9id0IwQUFDZ2FpcnhvRU1pQ3c1Rm9KNHFBS0NnS2tXZ25Tb0FvSjhxWlFBQW9FWWk3Q0YxY3dDZ0pDcmhJWEp5QUtCeUtXRUFjZ0R5QVB3TUFBSmhaV2wwN1NqOEtBRXBDQ2tBQVd4ejhTajRLR3dBY3dCbEFIUUFiUURwQUg4b2FBQndBQUNnTXlyd0ltRnljMndBb09RcEFBRmtiRm9QQlNsbEFBQ2dJeU5sb0tvcWM2Q3NLZ0RnckNvQS9vQUJabXh3QUJVcEdDa2ZLZlFoWTNsTVpHS2dMd0Job01RcGNnQUFvRDhqWmdBQTREWFlaTjFoQUFBQlpISW9LUmNEWlFCekFIV2dZQ1pwQUhRQUFLQmdKb0FCWTNOMUFEWXBSaWxoS1FBQllYVTZLVUFwY0FCem9KTWlBT0NUSWdEK2NBQnpvSlFpQU9DVUlnRCtkUUFBQVdKd1N5bFdLUUNoanlKbGN6NE5VQ2xsQUhRQVphQ1BJdkVBUHcwQW9aQWlaWE5JRFZzcFpRQjBBR1dna0NMeEFFa05BS0doSldGbVppbGJCSElBWlFGcktWd0VBS0NoSldFQWNnRHlBQU1OQUFKalpXMTBkeWw3S1g4cGdpbHlBQURnTmRqSTNIUUFiUUR1QU00QWFRRHNBQVlwWVFCeUFPWUFWdzBBQVdGeWlpbU9LWElBNXFBR0poRVNBQUZoYnBJcG95bHBJbWRvZEFBQUFXVndtU21nS1hBQWN3QnBBR3dBYndEdUFOa1hhQURwQUtBa2N3Q3ZZSUFDWW1OdGJuQUFyaW44S1k0TkpTb29LZ0NrZ2lKRlpHVnRibkJ5Yzd3cHZpbkNLY2dwekNuVUtkZ3AzQ2tBb01VcWJ3QjBBQUNndlNwa29JWWlid0IwQUFDZ3d5cjFJV3gwQUtEQktnQUJSV1hRS2RJcEFLRExLZ0NnaWlMc0lYVnpBS0MvS3VFaGNuSUFvSGtwZ0FGbGFYVUE0aW54S2ZRcGRBQUFvWUlpWlc3b0tld3BjUUR4b0lZaXZTbGxBSEVBOGFDS0l0RXBiUUFBb01jcUFBRmljUGdwK2lrQW9OVXFBS0RUS21NQWdLSjdJbUZqWlc1ekFBY3FEU29VS2hZcVJpaHdBSEFBY2dCdkFQZ0FJeWgxQUhJQWJBQjVBR1VBOFFDRERmRUFmQTJBQVdGbGN3QWNLaUlxUFNod0FIQUFjZ0J2QVBnQVBDaHhBUEVBT1NobkFBQ2dhaVlBcG9NaU1USXpSV1JsYUd4dGJuQnpQQ28vS2tJcVJTcEhLbElxV0NwakttY3FheXB6S25jcU80QzVBTGxBTzRDeUFMSkFPNEN6QUxOQUFLREdLZ0FCYjNOTEtrNHFkQUFBb0w0cWRRQmlBQUNnMkNwa29JY2lid0IwQUFDZ3hDcHpBQUFCYjNWZEttQXFiQUFBb01rbllnQUFvTmNxNFNGeWNnQ2dleW4xSVd4MEFLRENLZ0FCUldWdktuRXFBS0RNS2dDZ2l5THNJWFZ6QUtEQUtvQUJaV2wxQUgwcWpDcVBLblFBQUtHREltVnVneXFIS25FQThhQ0hJa1lxWlFCeEFQR2dpeUp3S20wQUFLRElLZ0FCWW5DVEtwVXFBS0RVS2dDZzFpcUFBVUZoYmdDZEtxRXFyQ3B5QUhJQUFLRFpJWElBQUFGb2NxWXFxQ3JyQUpVYWI2Q1pJZmNBeFFmM0lXRnlBS0FxS1d3QWFRQm5BRHVBM3dEZlFPRUx6eXJaS3R3cTZTcnNLdkVxQUFEMUtqUXJBQUFBQUFBQUFBQUFBRXdyYkNzQUFIRXJ2U3NBQUFBQUFBRFJLM0lDMUNvQUFBQUEyQ3JuSVdWMEFLQVdJOFJqY2dEckFPVUtnQUZoWlhrQTRTcmtLdWNxOGlGdmJtVmg1Q0ZwYkdOaFFtUnZBUFFBSWc1c0luSmxZd0FBb0JVamNnQUE0RFhZTWQwQUFtVnBhMi83S2hJcktDc3VLL0lCQUNzQUFBa3JaUUFBQVRSbTZnMEVLMjhBY2dEbEFPc05ZUUJ6b3JnREVDc0FBQUFBRWl0NUFHMEEwV01BQVdOdUZpc2xLMnNBQUFGaGN4c3JJU3R3QUhBQWNnQnZBUGdBRnc1cEFHMEFBS0E4SW5NQThBRDlEUUFCWVhNc0t5RXI4QUFYRG5JQWJnQTdnUDRBL2tEc0FUZ3JPeXN3RzJRQTVRQm5BbVVBY3dDQWdkY0FPMkprQUVNclJDdEpLOWRBWWFDZ0luSUFBS0F4S2dDZ01DcUFBV1Z3Y3dCUksxTXJhU3ZoQUFraDRxS2tJbHNyWHlzQUFBQUFZeXR2QUhRQUFLQTJJMmtBY2dBQW9QRXFiK0ExMkdYZGNnQnJBQUNnMmlyaEFIZ29jaUpwYldVQUFLQTBJSUFCWVdsd0FIWXJlU3UzSzJRQTVRQytEWUFEWVdSbGJYQnpkQUNGSzZNcm1pdW5LNndyc0N1eksyNGlaMnhsQUFDaXRTVmtiSEZ5a0N1VUs1b3JuQ3Z2SVhkdUFLQy9KZVVoWm5SbG9NTWw4UUFDQndDZ1hDSnBJbWRvZEFCbG9Ma2w4UUJkREc4QWRBQUFvT3dsYVNKdWRYTUFBS0E2S3V3aGRYTUFvRGtxWWdBQW9NMHA2U0Z0WlFDZ095cmxJbnBwZFcwQW9PSWpnQUZqYUhRQXdpdktLODByQUFGeWVjWXJ5U3NBNERYWXlkeEdaR01BZVFCYlpQSWhiMnRuWVFBQmFXL1VLOWNyZUFEMEFORVJhQ0psWVdRQUFBRnNjdDRyNXl0bEFHWUFkQUJoQUhJQWNnQnZBUGNBWFFicEpHZG9kR0Z5Y205M0FLQ2dJUUFKUVVoaFltTmtabWRvYkcxdmNISnpkSFYzQ2l3TkxCRXNIU3duTERFc1FDeExMRklzWWl4NkxJUXNqeXpMTE9nczdTei9MQW90Y2dEeUFBa0RZUUJ5QUFDZ1l5a0FBV055RlN3YkxIVUFkQUJsQUR1QStnRDZRUElBQ1ExeUFPTUJJeXdBQUNVc2VRQmVaSFlBWlFCdFlRQUJhWGtyTERBc2NnQmpBRHVBK3dEN1FFTmtnQUZoWW1nQU55dzZMRDBzY2dEeUFORU83Q0ZoWTNGaFlRRHlBT0FPQUFGcGNrUXNTQ3p6SVdoMEFLQitLUURnTmRneTNYSUFZUUIyQUdVQU80RDVBUGxBWVFGV0xGOHNjZ0FBQVd4eVdpeGNMQUNndnlFQW9MNGhiQUJyQUFDZ2dDVUFBV04wWml4MkxHOENiQ3dBQUFBQWN5eHlBRzRBWmFBY0kzSUFBS0FjSTI4QWNBQUFvQThqY2dCcEFBQ2crQ1VBQVdGc2ZpeUJMR01BY2dCcllUdUFxQUNvUUFBQlozQ0lMSXNzYndCdUFITmhaZ0FBNERYWVp0MEFBMkZrYUd4emRaa3NuaXluTExnc3V5ekZMSElBY2dCdkFQY0FDUTF2QUhjQWJnQmhBSElBY2dCdkFQY0EyQTVoSTNKd2IyOXVBQUFCYkhLdkxMTXNaUUJtQVBRQVd5eHBBR2NBYUFEMEFGMHNkUUR6QUtZT2FRQUFvY1VEYUd6QkxNSXMwbU52QUc0QXhXUHdJMkZ5Y205M2N3Q2d5Q0dBQVdOcGRBRFJMT0VzNUN4dkF0Y3NBQUFBQU40c2NnQnVBR1dnSFNOeUFBQ2dIU052QUhBQUFLQU9JMjRBWndCdllYSUFhUUFBb1BrbFl3QnlBQURnTmRqSzNJQUJaR2x5QVBNczl5ejZMRzhBZEFBQW9QQWk3Q0ZrWldsaGFRQm1vTFVsQUtDMEpRQUJZVzBETFFZdGNnRHlBTW9zYkFBN2dQd0EvRURoSW01bmJHVUFvS2NwZ0FkQlFrUmhZMlJsWm14dWIzQnljM29BSnkwcUxUQXROQzJiTFowdG9TMi9MY010eHkzVExkZ3QzQzNnTGZ3dGNnRHlBQkFEWVFCeUFIYWc2Q29Bb09rcVlRQnpBT2dBL2dJQUFXNXlPQzA4TGVjaGNuUUFvSndwZ0FObGEyNXdjbk4wQUprcFNDMU5MVlF0WGkxaUxZSXRZUUJ3QUhBQTRRQWFIRzhBZEFCb0FHa0FiZ0RuQUtFWGdBRm9hWElBb1NtekpGb3Rid0J3QVBRQWRDVm9vSlVoN3dENEpnQUJhWFZtTFdvdFp3QnRBT0VBdXlnQUFXSndiaTE0TFhNalpYUnVaWEVBY2VDS0lnRCtBT0RMS2dEK2N5TmxkRzVsY1FCeDRJc2lBUDRBNE13cUFQNEFBV2h5aGkyS0xXVUFkQURoQUJJcmFTTmhibWRzWlFBQUFXeHlraTJXTGVVaFpuUUFvTElpYVNKbmFIUUFBS0N6SW5rQU1tVGhJWE5vQUtDaUlvQUJaV3h5QUtjdHRDMjRMV0tpS0NLdUxRQUFBQUN5TFdFQWNnQUFvTHNpY1FBQW9Gb2k3Q0ZwY0FDZzdpSUFBV0owdkMxZUQyRUE4Z0JmRDNJQUFPQTEyRFBkZEFCeUFPa0FsUzF6QUhVQUFBRmljTTB0MEMwQTRJSWkwaUFBNElNaTBpQndBR1lBQU9BMTJHZmRjZ0J2QVBBQVdRdDBBSElBNlFDYUxRQUJZM1hrTGVndGNnQUE0RFhZeTl3QUFXSnc3QzMwTFc0QUFBRkZaWFV0OFMwQTRJb2lBUDV1QUFBQlJXVi9MZmt0QU9DTElnRCs2U0puZW1GbkFLQ2FLWUFEWTJWbWIzQnljd0FOTGhBdUpTNHBMaU11TGk0MEx1a2hjbU4xWVFBQlpHa1VMaUV1QUFGaVp4Z3VIQzVoQUhJQUFLQmZLbVVBY2FBbklnQ2dXU0xsSVhKd0FLQVlJWElBQU9BMTJEVGRjQUJtQUFEZ05kaG8zV1dnUUNKaEFIUUE2QUJxRDJNQWNnQUE0RFhZek56akN1UVJVQzRBQUZRdUFBQllMbUl1QUFBQUFHTXViUzV3TG5RdUFBQUFBSWd1a2k0QUFKb3VKeElxRW5RQWNnRHBBQjBTY2dBQTREWFlOZDBBQVVGaFd5NWVMbklBOGdEbkFuSUE4Z0NUQjc1akFBRkJZV1l1YVM1eUFQSUE0QUp5QVBJQWpBZGhBUEFBZWg1cEFITUFBS0Q3SW9BQlpIQjBBUGdSZVM2RExnQUJabXg5TG9BdUFPQTEyR25kZFFEekFQOFJhUUJ0QU9VQUJCSUFBVUZoaXk2T0xuSUE4Z0R1QW5JQThnQ2FCd0FCWTNHVkxnb1NjZ0FBNERYWXpkd0FBWEIwblM2aExtd0FkUUR6QUNVU2NnRHBBQ0FTQUFSaFkyVm1hVzl6ZGJFdXZDN0VMc2d1ekM3UEx0UXUyUzVqQUFBQmRYbTJMcnN1ZEFCbEFEdUEvUUQ5UUU5a0FBRnBlY0F1d3k1eUFHTUFkMkZMWkc0QU80Q2xBS1ZBY2dBQTREWFlOdDFqQUhrQVYyUndBR1lBQU9BMTJHcmRZd0J5QUFEZ05kak8zQUFCWTIzZEx0OHVlUUJPWkd3QU80RC9BUDlBQUFWaFkyUmxabWhwYjNOMzh5NzNMdjh1QWk4TUx4QXZFeThZTHgwdklpOWpJblYwWlFCNllRQUJZWG43THY0dThpRnZibjVoTjJSdkFIUUFmR0VBQVdWMEJpOEtMM1FBY2dEbUFCOFFZUUMyWTNJQUFPQTEyRGZkWXdCNUFEWms1eUp5WVhKeUFLRGRJWEFBWmdBQTREWFlhOTFqQUhJQUFPQTEyTS9jQUFGcWJpWXZLQzhBb0EwZ2FnQUFvQXdnXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLWRhdGEtaHRtbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-xml.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-xml.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xmlDecodeTree: () => (/* binding */ xmlDecodeTree)\n/* harmony export */ });\n/* harmony import */ var _internal_decode_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/decode-shared.js */ \"(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/decode-shared.js\");\n// Generated using scripts/write-decode-map.ts\n\nconst xmlDecodeTree = /* #__PURE__ */ (0,_internal_decode_shared_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase64)(\"AAJhZ2xxBwARABMAFQBtAg0AAAAAAA8AcAAmYG8AcwAnYHQAPmB0ADxg9SFvdCJg\");\n//# sourceMappingURL=decode-data-xml.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS14bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUM0RDtBQUNyRCxzQ0FBc0Msd0VBQVk7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcmNhZGUtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZW50aXRpZXMvZGlzdC9lc20vZ2VuZXJhdGVkL2RlY29kZS1kYXRhLXhtbC5qcz80OTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCB1c2luZyBzY3JpcHRzL3dyaXRlLWRlY29kZS1tYXAudHNcbmltcG9ydCB7IGRlY29kZUJhc2U2NCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kZWNvZGUtc2hhcmVkLmpzXCI7XG5leHBvcnQgY29uc3QgeG1sRGVjb2RlVHJlZSA9IC8qICNfX1BVUkVfXyAqLyBkZWNvZGVCYXNlNjQoXCJBQUpoWjJ4eEJ3QVJBQk1BRlFCdEFnMEFBQUFBQUE4QWNBQW1ZRzhBY3dBbllIUUFQbUIwQUR4ZzlTRnZkQ0pnXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLWRhdGEteG1sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/generated/decode-data-xml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/bin-trie-flags.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/bin-trie-flags.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinTrieFlags: () => (/* binding */ BinTrieFlags)\n/* harmony export */ });\n/**\n * Bit flags & masks for the binary trie encoding used for entity decoding.\n *\n * Bit layout (16 bits total):\n * 15..14 VALUE_LENGTH   (+1 encoding; 0 => no value)\n * 13     FLAG13.        If valueLength>0: semicolon required flag (implicit ';').\n *                       If valueLength==0: compact run flag.\n * 12..7  BRANCH_LENGTH  Branch length (0 => single branch in 6..0 if jumpOffset==char) OR run length (when compact run)\n * 6..0   JUMP_TABLE     Jump offset (jump table) OR single-branch char code OR first run char\n */\nvar BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"FLAG13\"] = 8192] = \"FLAG13\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 8064] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\n//# sourceMappingURL=bin-trie-flags.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2ludGVybmFsL2Jpbi10cmllLWZsYWdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QywrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FyY2FkZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9lbnRpdGllcy9kaXN0L2VzbS9pbnRlcm5hbC9iaW4tdHJpZS1mbGFncy5qcz8zOTVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQml0IGZsYWdzICYgbWFza3MgZm9yIHRoZSBiaW5hcnkgdHJpZSBlbmNvZGluZyB1c2VkIGZvciBlbnRpdHkgZGVjb2RpbmcuXG4gKlxuICogQml0IGxheW91dCAoMTYgYml0cyB0b3RhbCk6XG4gKiAxNS4uMTQgVkFMVUVfTEVOR1RIICAgKCsxIGVuY29kaW5nOyAwID0+IG5vIHZhbHVlKVxuICogMTMgICAgIEZMQUcxMy4gICAgICAgIElmIHZhbHVlTGVuZ3RoPjA6IHNlbWljb2xvbiByZXF1aXJlZCBmbGFnIChpbXBsaWNpdCAnOycpLlxuICogICAgICAgICAgICAgICAgICAgICAgIElmIHZhbHVlTGVuZ3RoPT0wOiBjb21wYWN0IHJ1biBmbGFnLlxuICogMTIuLjcgIEJSQU5DSF9MRU5HVEggIEJyYW5jaCBsZW5ndGggKDAgPT4gc2luZ2xlIGJyYW5jaCBpbiA2Li4wIGlmIGp1bXBPZmZzZXQ9PWNoYXIpIE9SIHJ1biBsZW5ndGggKHdoZW4gY29tcGFjdCBydW4pXG4gKiA2Li4wICAgSlVNUF9UQUJMRSAgICAgSnVtcCBvZmZzZXQgKGp1bXAgdGFibGUpIE9SIHNpbmdsZS1icmFuY2ggY2hhciBjb2RlIE9SIGZpcnN0IHJ1biBjaGFyXG4gKi9cbmV4cG9ydCB2YXIgQmluVHJpZUZsYWdzO1xuKGZ1bmN0aW9uIChCaW5UcmllRmxhZ3MpIHtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiVkFMVUVfTEVOR1RIXCJdID0gNDkxNTJdID0gXCJWQUxVRV9MRU5HVEhcIjtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiRkxBRzEzXCJdID0gODE5Ml0gPSBcIkZMQUcxM1wiO1xuICAgIEJpblRyaWVGbGFnc1tCaW5UcmllRmxhZ3NbXCJCUkFOQ0hfTEVOR1RIXCJdID0gODA2NF0gPSBcIkJSQU5DSF9MRU5HVEhcIjtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiSlVNUF9UQUJMRVwiXSA9IDEyN10gPSBcIkpVTVBfVEFCTEVcIjtcbn0pKEJpblRyaWVGbGFncyB8fCAoQmluVHJpZUZsYWdzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbi10cmllLWZsYWdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/bin-trie-flags.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/decode-shared.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/decode-shared.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64)\n/* harmony export */ });\n/*\n * Shared base64 decode helper for generated decode data.\n * Assumes global atob is available.\n */\nfunction decodeBase64(input) {\n    const binary = \n    // eslint-disable-next-line n/no-unsupported-features/node-builtins\n    typeof atob === \"function\"\n        ? // Browser (and Node >=16)\n            // eslint-disable-next-line n/no-unsupported-features/node-builtins\n            atob(input)\n        : // Older Node versions (<16)\n            // eslint-disable-next-line n/no-unsupported-features/node-builtins\n            typeof Buffer.from === \"function\"\n                ? // eslint-disable-next-line n/no-unsupported-features/node-builtins\n                    Buffer.from(input, \"base64\").toString(\"binary\")\n                : // eslint-disable-next-line unicorn/no-new-buffer, n/no-deprecated-api\n                    new Buffer(input, \"base64\").toString(\"binary\");\n    const evenLength = binary.length & ~1; // Round down to even length\n    const out = new Uint16Array(evenLength / 2);\n    for (let index = 0, outIndex = 0; index < evenLength; index += 2) {\n        const lo = binary.charCodeAt(index);\n        const hi = binary.charCodeAt(index + 1);\n        out[outIndex++] = lo | (hi << 8);\n    }\n    return out;\n}\n//# sourceMappingURL=decode-shared.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2VudGl0aWVzL2Rpc3QvZXNtL2ludGVybmFsL2RlY29kZS1zaGFyZWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcmNhZGUtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZW50aXRpZXMvZGlzdC9lc20vaW50ZXJuYWwvZGVjb2RlLXNoYXJlZC5qcz83NDY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBTaGFyZWQgYmFzZTY0IGRlY29kZSBoZWxwZXIgZm9yIGdlbmVyYXRlZCBkZWNvZGUgZGF0YS5cbiAqIEFzc3VtZXMgZ2xvYmFsIGF0b2IgaXMgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGlucHV0KSB7XG4gICAgY29uc3QgYmluYXJ5ID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG4vbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgIHR5cGVvZiBhdG9iID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAvLyBCcm93c2VyIChhbmQgTm9kZSA+PTE2KVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG4vbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgYXRvYihpbnB1dClcbiAgICAgICAgOiAvLyBPbGRlciBOb2RlIHZlcnNpb25zICg8MTYpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbi9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICB0eXBlb2YgQnVmZmVyLmZyb20gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG4vbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShpbnB1dCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIilcbiAgICAgICAgICAgICAgICA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLW5ldy1idWZmZXIsIG4vbm8tZGVwcmVjYXRlZC1hcGlcbiAgICAgICAgICAgICAgICAgICAgbmV3IEJ1ZmZlcihpbnB1dCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgY29uc3QgZXZlbkxlbmd0aCA9IGJpbmFyeS5sZW5ndGggJiB+MTsgLy8gUm91bmQgZG93biB0byBldmVuIGxlbmd0aFxuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50MTZBcnJheShldmVuTGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBvdXRJbmRleCA9IDA7IGluZGV4IDwgZXZlbkxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgICAgICBjb25zdCBsbyA9IGJpbmFyeS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgY29uc3QgaGkgPSBiaW5hcnkuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICBvdXRbb3V0SW5kZXgrK10gPSBsbyB8IChoaSA8PCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1zaGFyZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/htmlparser2/node_modules/entities/dist/esm/internal/decode-shared.js\n");

/***/ })

};
;